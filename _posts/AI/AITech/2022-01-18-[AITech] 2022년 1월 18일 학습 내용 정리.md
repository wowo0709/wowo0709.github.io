---
layout: single
title: "[AITech] 2022년 1월 18일 학습 내용 정리"
categories: ['AI', 'AITech']
toc: true
toc_sticky: true
tag: ['자료구조','파이써닉코딩','모듈과프로젝트','예외/파일/로그']
---



<br>

## 강의 복습 내용

### 1. Python data structure

**Stack**

* 나중에 넣은 데이터를 먼저 반환하도록 설계된 메모리 구조(LIFO)
* 리스트를 사용하여 스택 구조 표현 가능
  * push는 append(), pop은 pop() 사용

**Queue**

* 먼저 넣은 데이터를 먼저 반환하도록 설계된 메모리 구조(FIFO)
* 리스트를 사용하여 큐 구조 표현 가능
  * put은 append(), get은 pop(0) 사용

**Tuple**

* 값의 변경이 불가능한 리스트
  * 선언 시 "( )"로 선언
* **set, dict 등** 원소(키)로 hashable element를 요구하는 자료 구조에 사용 가능

**Set**

* 값을 순서없이 저장, 중복 불허하는 자료형

```python
s1 = set([1,2,3,4,5])
s2 = set([3,4,5,6,7])
s1 = s1.union(s2) # s1 |= s2 (합집합)
# {1,2,3,4,5,6,7}
s1 = s1.intersection(s2) # s1 &= s2 (교집합)
# {3,4,5}
s1 = s1.difference(s2) # s1 -= s2 (차집합)
# {1,2}
```

**Dict**

* 데이터를 저장할 때 구분 지을 수 있는 값을 함께 저장(key-value)
* key 값을 활용하여, value 값을 관리
* 다른 언어에서는 **Hash Table**이라는 용어를 사용

**Collections**

* Python Built-in 확장 자료 구조(모듈)
* 편의성, 실행 효율 등을 사용자에게 제공

- `deque`
  - rotate, reverse 등 Linked List의 특성을 지원
  - 효율적 메모리 구조로 처리 속도 향상

```python
# deque - Stack과 Queue를 구현하는데 List보다 효율적이고 빠른 저장 방식을 제공
# using collections module
from collections import deque
import time

start_time = time.time()
deque_list = deque()
# deque
for i in range(10**6):
    deque_list.append(i)
for i in range(10**6):
    deque_list.popleft()
print(time.time() - start_time, "seconds")
'''0.17937803268432617 seconds'''
# using list
import time

start_time = time.time()
just_list = []
for i in range(10**6):
    just_list.append(i)
for i in range(10**6):
    just_list.pop(0)
print(time.time() - start_time, "seconds")
'''102.59535932540894 seconds'''
```

* `OrderedDict`
  * 데이터를 입력한 순서대로 dict를 반환
  * 일반 dict도 python 3.6부터는 입력한 순서를 보장하여 출력
* `defaultdict`
  * Dict type의 값에 기본 값을 지정, 신규값 생성 시 사용하는 방법

```python
from collections import defaultdict
d = defaultdict(lambda: 0) # 함수 형태로 사용
print(d["first"])
# 0
```

* `Counter`
  * Sequence type의 data element들의 갯수를 dict 형태로 반환

```python
from collections import Counter

# sequence -> dict
c = Counter('gallahad')
print(c)
'''
Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})
'''

# dict -> list
c = Counter({'red':4, 'blue':2})
print(c)
print(c.elements())
print(list(c.elements()))
'''
Counter({'red': 4, 'blue': 2})
<itertools.chain object at 0x000001EDC28B65E0>
['red', 'red', 'red', 'red', 'blue', 'blue']
'''

# set의 연산들을 지원
c = Counter(a=4, b=2, c=0, d=-2)
d = Counter(a=1, b=2, c=3)
print(c+d)
print(c&d)
print(c|d)
c.subtract(d)
print(c)
'''
Counter({'a': 5, 'b': 4, 'c': 3})
Counter({'b': 2, 'a': 1})
Counter({'a': 4, 'c': 3, 'b': 2})
Counter({'a': 3, 'b': 0, 'd': -2, 'c': -3})
'''

# 많은 순서대로 반환
Counter('Hello My name is Bread').most_common()
'''
[(' ', 4),
 ('e', 3),
 ('l', 2),
 ('a', 2),
 ('H', 1),
 ('o', 1),
 ('M', 1),
 ('y', 1),
 ('n', 1),
 ('m', 1),
 ('i', 1),
 ('s', 1),
 ('B', 1),
 ('r', 1),
 ('d', 1)]
'''
```

* `namedtuple`
  * Tuple 형태로 Data 구조체를 저장
  * 저장된는 data의 varaible을 사전에 지정해서 저장

```python
from collections import namedtuple
Point = namedtuple('Point', ['x','y'])
p = Point(11, y=22)
print(p[0] + p[1])
# 33

x, y = p
print(x, y)
print(p.x, p.y)
print(Point(11, 22))
'''
11 22
11 22
Point(x=11, y=22)
'''
```



<br>

### 2. Pythonic code

* 파이썬 스타일의 코딩 기법
* 파이썬 특유의 문법을 활용하여 효율적으로 코드를 표현

**split&join**

```python
# split
items = 'zero one two three'.split()
print(items)
# ['zero', 'one', 'two', 'three']

# join
colors = ['red','blue','green','yellow']
print('&'.join(colors))
# red&blue&green&yellow
```



**list comprehension**

* list를 사용하여 간단히 다른 list를 만드는 기법

```python
result = [i for i in range(10)]
result2 = [i for i in range(10) if i%2 == 0]
print(result, result2)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [0, 2, 4, 6, 8]

# nested loop
word_1 = "Hello"
word_2 = "World"
result3 = [i+j for i in word_1 for j in word_2]
print(result3)
# ['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']

# conditional 
case_1 = ["A","B","C"]
case_2 = ["D","E","A"]
result4 = [i+j for i in case_1 for j in case_2 if not i==j]
result5 = [i+j if not i==j else i for i in case_1 for j in case_2]
print(result4, result5)
'''
['AD', 'AE', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA'] 
['AD', 'AE', 'A', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA']
'''
# 2-d list
result6 = [i+j for i in case_1 for j in case_2] # 1-d list -> case1이 바깥 loop, case2가 안쪽 loop
result7 = [[i+j for i in case_1] for j in case_2] # 2-d list -> case1이 안쪽 loop, case2가 바깥 loop
print(result6, result7)
'''
['AD', 'AE', 'AA', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA'] 
[['AD', 'BD', 'CD'], ['AE', 'BE', 'CE'], ['AA', 'BA', 'CA']]
'''
```



**enumerate&zip**

```python
# enumerate
for i,v in enumerate("ABC"):
    print(i,v)
'''
0 A
1 B
2 C
'''
my_str = "ABCD"
my_dict = {v:i for i,v in enumerate(my_str)}
print(my_dict)
# {'A': 0, 'B': 1, 'C': 2, 'D': 3}

# zip
alist = ['a1','a2','a3']
blist = ['b1','b2','b3']
for a,b in zip(alist, blist):
    print(a,b)
'''
a1 b1
a2 b2
a3 b3
'''
[sum(x) for x in zip((1,2,3),(10,20,30),(100,200,300))]
# [111, 222, 333]
```



**lambda&map&reduce**

코드의 직관성이 떨어져서 lambda나 reduce는 python3에서 사용을 권장하지는 않음!

그러나 여전히 많은 곳에서 사용 중

* lambda

```python
f = lambda x,y: x+y
print(f(1,4))
# print((lambda x: x+1)(5))
# 5
'''
PEP8에서는 lambda의 사용을 권장하지는 않음
- 어려운 문법
- 테스트의 어려움
- 문서화 docstring 지원 미비
- 코드 해석의 어려움
- 이름이 존재하지 않는 함수의 출현
- 그래도 많이 쓴다...
'''
```

* map
  * python3부터는 map generator를 생성하기 때문에 list로 사용하려면 `list(map(...))`와 같이 사용

```python
# map
ex = [1,2,3,4,5]
f = lambda x, y: x+y
print(list(map(f,ex,ex)))
# [2, 4, 6, 8, 10]
list(
    map(
    lambda x: x**2 if x%2 == 0
    else x,
    ex)
)
# [1, 4, 3, 16, 5]
```

* reduce

```python
# reduce
from functools import reduce
print(reduce(lambda x, y: x+y, [1,2,3,4,5],10)) # reduce(function,sequence,initializer)
# 25
```







**generator**

* 내부적 구현으로 `__iter__`와 `__next__`가 사용
* iter()와 next() 함수로 iterable 객체를 iterator object로 사용

```python
cities = ["Seoul", "Busan", "Jeju"]

iter_obj = iter(cities)

print(next(iter_obj))
print(next(iter_obj))
print(next(iter_obj))
print(next(iter_obj))
'''
Seoul
Busan
Jeju
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
<ipython-input-48-8d293490d776> in <module>
      6 print(next(iter_obj))
      7 print(next(iter_obj))
----> 8 print(next(iter_obj))

StopIteration: 
'''
```

* `generator`
  * iterable object를 특수한 형태로 사용
  * element가 사용되는 시점에 값을 메모리에 반환
    * yeild를 사용해 한 번에 하나의 element만 반환
  * 메모리를 훨씬 더 절약
    * 파일 데이터 등의 대용량 데이터 처리 시 사용

```python
def general_list(value):
    result = []
    for i in range(value):
        result.append(i)
    return result

result = general_list(50)
print(result,sys.getsizeof(result))
'''
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49] 520
'''

def generator_list(value):
    result = []
    for i in range(value):
        yield i
        
result = generator_list(50)
print(result, sys.getsizeof(result))
'''
<generator object generator_list at 0x000001EDC28B9C10> 112
'''
# 값을 불러오려면 for문 사용
result = list(generator_list(50))
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]
for a in generator_list(50):
    print(a,end=' ')
# 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 
```



**asterisk**

* 함수에 입력되는 arguments의 다양한 형태
  1. Keyword arguments
  2. Default arguments
  3. Variable-length arguments
* Keyword arguments

```python
def print_something(my_name, your_name):
    print("Hello {0}, My name is {1}".format(your_name, my_name))
    
print_something("Sungchul","TEAMLAB")
print_something(your_name="TEAMLAB",my_name="Sungchul")

'''
Hello TEAMLAB, My name is Sungchul
Hello TEAMLAB, My name is Sungchul
'''
```

* Default arguments

```python
def print_something_2(my_name, your_name="TEAMLAB"):
    print("Hello {0}, My name is {1}".format(your_name, my_name))
    
print_something_2("Sungchul","TEAMLAB")
print_something_2("Sungchul")

'''
Hello TEAMLAB, My name is Sungchul
Hello TEAMLAB, My name is Sungchul
'''
```

* Variable-length parameter
  * **개수가 정해지지 않은 변수**를 함수의 parameter로 사용하는 법
  * **Asterisk(*)** 기호를 사용하여 함수의 parameter를 표시함
  * 입력된 값을 **tuple type**으로 사용
  * 가변 인자는 오직 한 개만 맨 마지막 parameter로 사용 가능

```python
# 가변 인자 사용하기
def asterisk_test(*args):
    x, y, z = args
    print(x, y, z, sum(args))
    
asterisk_test(3,4,5)

# 3 4 5 12
```



* Keyword varaiable-length parameter
  * **Asterisk(*) 두 개**를 사용하여 함수의 parameter를 표시
  * 입력된 값은 **dict type**으로 사용
  * 가변 인자는 오직 한 개만 기존 가변 인자 다음에 사용

```python
# 키워드 가변인자 사용하기
def kwargs_test(one, two, *args, **kwargs):
    print(one+two+sum(args))
    print(kwargs)
    
kwargs_test(3,4,5,6,7,8,9,first=3,second=4,third=5)

'''
42
{'first': 3, 'second': 4, 'third': 5}
'''
```

**가변 인자 및 키워드 가변 인자는 머신러닝에서 매우 많이 사용되므로 잘 알아둘 것!!**

* Unpacking
  * tuple, dict 등 자료형에 들어가 있는 값을 unpacking
  * 함수의 입력값, zip 등에 유용하게 사용 가능

```python
# 언패킹
def asterisk_test(a, *args):
    print(a, args)
    print(type(args))
    
asterisk_test(1,*(2,3,4,5,6))
'''
1 (2, 3, 4, 5, 6)
<class 'tuple'>
'''
def asterisk_test(a, args):
    print(a, *args)
    print(type(args))
    
asterisk_test(1,(2,3,4,5,6))
'''
1 2 3 4 5 6
<class 'tuple'>
'''

# zip에 사용하기
for data in zip(*([1,2],[3,4],[5,6])):
    print(data)
'''
(1, 3, 5)
(2, 4, 6)
'''
```



<br>

### 3. Python object-oriented programming

만들어 놓은 코드를 **재사용**하고 싶다!!

* 객체: 실생활에서 일종의 물건
  * **속성**과 **행동**을 가짐
* OOP는 이러한 객체 개념을 프로그램으로 표현
  * **속성은 변수, 행동은 함수**로 표현
* OOP는 설계도에 해당하는 **클래스**와 실제 구현체인 **인스턴스**로 나뉨

```python
class SoccerPlayer(object):
    def __init__(self, name, position, back_number): # initializing function
        self.name = name
        self.position = position
        self.back_number = back_number
        
    def __str__(self): # majic function(mangling)
        return "Hello, My name is %s. I play in %s in center "% \
        (self.name, self.position)
    
jinhyun = SoccerPlayer("Jinhyun", "MF", 10)
print(jinhyun)
# Hello, My name is Jinhyun. I play in MF in center 
```

**OOP characteristics**

* Inheritance
* Polymorphism

```python
class Animal:
    def __init__(self, name):
        self.name = name
        
    def talk(self):
        return "None"
        
class Cat(Animal): # 상속
    def talk(self): # 재정의
        return "Meow!"
    
class Dog(Animal): # 상속
    def talk(self): # 재정의
        return "Woof! Woof!"
    
    
animals = [Animal('Missy'), Cat('Ruby'), Dog('Lassie')]

for animal in animals:
    print(animal.name + ":" + animal.talk())
    
'''
Missy:None
Ruby:Meow!
Lassie:Woof! Woof!
'''
```



* Visibility
  * 객체의 정보를 볼 수 있는 레벨을 조절하는 것

```python
class Inventory(object):
    def __init__(self):
        self.__items = [] # private 변수로 선언, 타객체가 접근하지 못 함
        
    @property # property decorator: 숨겨진 변수를 반환하게 해 줌
    def items(self):
        return self.__items
    	# return deepcopy(self.__items) -> 주로 복사체를 리턴해 줌
        
...
items = my_inventory.items # property decorator로 함수를 변수처럼 호출
```

**Decorate**

* first-class objects
  * 일등함수 또는 일급객체
  * 변수나 데이터 구조에 할당이 가능한 객체
  * 파라미터로 전달이 가능 + 리턴 값으로 사용 가능
  * **파이썬의 함수는 모두 일급함수**

```python
def formula(method, argument_list):
    return [method(value) for value in argument_list]
```

* Inner function
  * 함수 안의 또 다른 함수
  * **closures: inner function을 return 값으로 반환**
    * 같은 이름으로 다양한 함수 사용 가능

```python
def print_msg(msg):
    def printer():
        print(msg)
    return printer

another = print_msg("Hello, Python")
another()
# Hello, Python
```

* Decorator function
  * 복잡한 클로저 함수를 간단하게!

```python
def star(func): # func = percent
    def inner(*args, **kwargs):
        print("*"*30)
        func(*args, **kwargs) 
        print(func)
        print("*"*30)
    return inner

def percent(func): # func = printer
    def inner(*args, **kwargs): # *args = msg
        print("%"*30)
        func(*args, **kwargs) 
        print(func)
        print("%"*30)
    return inner

@star
@percent
def printer(msg):
    print(msg)
printer("Hello")

'''
******************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Hello
<function printer at 0x000001EDC28B69D0>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<function percent.<locals>.inner at 0x000001EDBF8BD1F0>
******************************
'''
```

* Decorator function with argument
  * 데코레이터 함수에 인자를 전달하려면 wrapper 함수가 필요하다. 

```python
def generate_power(exponent): # 2
    print(exponent)
    def wrapper(f): # f = raise_two
        print(f)
        def inner(*args): # *args = n = 7
            print(args)
            result = f(*args)
            return exponent**result
        return inner
    return wrapper

@generate_power(2)
def raise_two(n):
    return n**2

print(raise_two(7))

'''
2
<function raise_two at 0x000001EDBFA39790>
(7,)
562949953421312
'''
```

**이해하기 좀 어렵지만 데코레이터 함수 호출 순서는 `(데코레이터 인자 -> 다음 데코레이터 함수)... -> 원 함수 -> 원 함수 인자` 순이라 생각하면 될 듯..!!**

<br>

### 4. Module and project

**Module**

* 하나의 큰 프로그램은 여러 작은 프로그램 조각들, 즉 모듈들을 모아서 개발
* 프로그램을 모듈화시키면 다른 프로그램에서 사용하기 쉬움
  * 예) 카카오톡 게임을 위한 카카오톡 로그인 모듈
* 파이썬의 모듈 == .py 파일
* namespace
  * 모듈을 호출할 때 범위를 정하는 방법

```python
# 1. Alias 설정하기 - 모듈명을 별칭을 사용
import fah_converter as fah
print(fah.convert_c_to_f(41.6))

# 2. 모듈에서 특정 함수 또는 클래스만 호출하기
from fah_converter import convert_c_to_f
print(convert_c_to_f(41.6))

# 3. 모듈에서 모든 함수 또는 클래스를 호출
from fah_converter import *
print(conver_c_to_f(41.6))
```

**Package**

* 하나의 대형 프로젝트를 만드는 코드의 묶음
* \_\_init\_\_, \_\_main\_\_ 등 키워드 파일명이 사용됨

1. 기능들을 세부적으로 나눠 폴더로 만듦

   ![image-20220118152008248](https://user-images.githubusercontent.com/70505378/150050515-36aae277-dfc0-40b7-aa47-58aba10f182e.png)

2. 각 폴더별로 필요한 모듈을 구현

![image-20220118152029500](https://user-images.githubusercontent.com/70505378/150050517-e2742f2a-8deb-4796-9640-4533a17f881a.png)

3. 폴더별로 `__init__.py` 구성하기

   * 현재 폴더가 패키지임을 알리는 초기화 스크립트

   * 없을 경우 패키지로 간주하지 않음(3.3+ 부터는 상관 없음)

   * 하위 폴더와 py 파일(모듈)을 모두 포함

   * import와 `__all__` keyword 사용

```python
# game.__init__.py
__all__ = ['image', 'stage'. 'sound']

from . import image
from . import stage
from . import sound
```

![image-20220118151405601](https://user-images.githubusercontent.com/70505378/150050510-b9a19bd4-6d99-44de-8fc4-4527c9a6f4fc.png)

4. `__main__.py` 파일 만들기

```python
from stage.main import game_start
from stage.sub import set_stage_level
from image.character import show_character
from sound.bgm import bgm_play

if __name__ = '__main__':
    game_start()
    set_stage_level(5)
    bgm_play(10)
    show_character()
```

✋ [참고] package namespace

```python
# 1. 절대 참조
from game.graphic.render import render_test()

# 2. 상대 참조
from .render import render_test() # .: 현재 디렉토리 기준
from ..sound.echo import echo_test() # ..: 부모 디렉토리 기준
```

5. 패키지 이름으로 호출하기 
   * `__main__.py` 실행

<br>

### 5. Exception/File/Log handling

#### Exception Handling

`Exception`은 **예상이 가능한 예외**와 **예상이 불가능한 예외**로 구분할 수 있다. 

* 예상 가능한 예외
  * 발생 여부를 사전에 인지할 수 있는 예외
  * 사용자의 잘못된 입력, 파일 호출 시 파일 없음 등
  * 개발자가 반드시 명시적으로 정의해야 함
* 예상 불가능한 예외
  * 인터프리터 과정에서 발생하는 예외
  * 리스트의 범위를 넘어가는 값 호출 등

* try~except

```python
for i in range(10):
    try:
    	print(10 / i)
    except ZeroDivisionError as e:
        print(e)
        print("Not divided by 0")
```

* try\~except\~else
  * Exception이 발생하지 않은 경우에만 else문 실행

```python
for i in range(10):
    try:
        result = 10 / i
    except ZeroDivisionError:
        print("Not divided by 0")
    else:
        print(10 / i)
```

* try\~except\~finally
  * 예외 발생과 상관없이 무조건 finally 문 실행

```python
try:
    for i in range(1, 10):
        result = 10 // i
        print(result)
except ZeroDivisionError:
    print("Not divided by 0")
finally:
    print("종료되었습니다.")
```

* raise
  * 필요에 따라 강제 Exception 발생

```python
while True:
    value = input("변환할 정수 값을 입력해주세요")
    for digit in value:
        if digit not in "0123456789":
            raise ValueError("숫자값을 입력하지않으셨습니다")

print("정수값으로 변환된 숫자 -", int(value))
```

* assert
  * 특정 조건에 만족하지 않을 경우 예외 발생

```python
def get_binary_nmubmer(decimal_number):
    assert isinstance(decimal_number, int)
    return bin(decimal_number)

print(get_binary_nmubmer(10))
```

<br>

#### File Handling

* 기본적인 파일 종류로 text 파일과 binary 파일로 나눔
  * Binary 파일
    * 컴퓨터만 이해할 수 있는 형태인 이진법 형식으로 저장된 파일
    * 일반적으로 메모장으로 열면 내용이 깨져 보임
    * 엑셀파일, 워드파일 등
  * Text 파일
    * 인간도 이해할 수 있는 형태인 문자열 형식으로 저장된 파일
    * 메모장으로 열면 내용 확인 가능
    * 메모장에 저장된 파일, HTML 파일, 파이썬 코드 파일 등
* 컴퓨터는 text 파일을 처리하기 위해 binary 파일로 변환시킴
* 모든 text 파일도 실제로는 binary 파일

* 파일 읽기

```python
# 파일 읽기
f = open("i_have_a_dream.txt", "r" )
contents = f.read()
print(contents)
f.close()
# or
with open("i_have_a_dream.txt", "r") as my_file:
    contents = my_file.read()
    print (type(contents), contents)
    
# 한 줄씩 읽기
with open("i_have_a_dream.txt", "r") as my_file:
    content_list = my_file.readlines() #파일 전체를 list로 반환
    print(type(content_list)) #Type 확인
    print(content_list) #리스트 값 출력
```

* 파일 쓰기

```python
f = open("count_log.txt", 'w', encoding="utf8") # mode='a'로 지정 시 기존 파일 내용에 추가
for i in range(1, 11):
    data = "%d번째 줄입니다.\n" % i
    f.write(data)
f.close()
```

* 파이썬의 directory 다루기
  * 최근에는 pathlib 모듈을 사용하여 path를 객체로 다움

```python
# os
import os
if not os.path.isdir("log"):
    os.mkdir("log")
```

* Pickle로 객체 저장하기(영속화)

```python
import pickle
f = open("list.pickle", "wb")
test = [1, 2, 3, 4, 5]
pickle.dump(test, f)
f.close()

f = open("list.pickle", "rb")
test_pickle = pickle.load(f)
print(test_pickle)
f.close()
```

<br>

#### Logging Handling

**로그 남기기**

* 프로그램이 실행되는 동안 일어나는 정보를 기록으로 남기기
* 유저의 접근, 프로그램의 Exception, 특정 함수의 사용 등
* Console 화면에 출력, 파일에 남기기, DB에 남기기 등

**logging level**

* DEBUG > INFO > WARNING > ERROR > CRITICAL

| Level    | 개요                                                         | 예시                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| debug    | 개발 시 처리 기록을 남겨야 하는 로그 정보를 남김             | - 다음 함수로 A를 호출함<br />- 변수 A를 무엇으로 변경함     |
| info     | 처리가 진행되는 동안의 정보를 알림                           | - 서버 시작/종료<br />- 사용자 A가 프로그램에 접속함         |
| warning  | 사용자가 잘못 입력한 정보나 처리는 가능하나 원래 개발 시 의도치 않는 정보가 들어왔을 때 알림 | - str 입력을 기대했으나 int 입력<br />- 함수에 argument로 이차원 리스트를 기대했으나 일차원 리스트가 들어옴 |
| error    | 잘못된 처리로 인해 에러가 났으나, 프로그램은 동작할 수 있음을 알림 | - 파일에 기록을 해야 하는데 파일이 없음<br />- 외부 서비스와 연결 불가 |
| critical | 잘못된 처리로 데이터 손실이나 더이상 프로그램이 동작할 수 없음을 알림 | - 잘못된 접근으로 해당 파일이 삭제됨<br />- 사용자의 의한 강제 종료 |

```python
import logging
logger = logging.getLogger("main")

stream_handler = logging.FileHandler(
    "my_log", mode='w', encoding="utf8")
logger.addHandler(stream_handler)
```

실제 프로그램을 실행할 땐 '데이터 파일 위치, 파일 저장 장소, Operation Type' 등 여러 설정이 필요. 이러한 정보를 설정해주는 방법으로 **파일에 저장해두는 configparser**와 **실행 시점에 입력하는 argparser**가 있다. 

**Configparser**

* 프로그램의 실행 설정을 file에 저장
* Section, Key, Value 값의 형태로 설정된 설정 파일을 사용
* 설정 파일을 Dict Type으로 호출 후 사용

```python
import configparser
config = configparser.ConfigParser()
config.sections()

config.read('example.cfg')
config.sections()

for key in config['SectionOne']:
    print(key)
    
config['SectionOne']["status"]
```

* example.cfg 파일

![image-20220118210926186](https://user-images.githubusercontent.com/70505378/150050520-3350e6a0-62a5-41c4-85da-3bec37616016.png)

**Argparser**

* Console 창에서 프로그램 실행 시 Setting 정보를 저장
* 거의 모든 Console 기반 Python 프로그램 기본으로 제공
* 특수 모듈도 많이 존재하지만(TF), 일반적으로 argparse를 사용
* Command-Line Option 이라고 부름

```python
def main(): 
    parser = argparse.ArgumentParser(description='PyTorch MNIST Example') 
    parser.add_argument('--batch-size', type=int, default=64, metavar='N', help='input batch size for training (default: 
    64)') 
    parser.add_argument('--test-batch-size', type=int, default=1000, metavar='N', help='input batch size for testing 
    (default: 1000)') 
    parser.add_argument('--epochs', type=int, default=10, metavar='N', help='number of epochs to train (default: 10)') 
    parser.add_argument('--lr', type=float, default=0.01, metavar='LR', help='learning rate (default: 0.01)') 
    parser.add_argument('--momentum', type=float, default=0.5, metavar='M', help='SGD momentum (default: 0.5)') 
    parser.add_argument('--no-cuda', action='store_true', default=False, help='disables CUDA training') 
    parser.add_argument('--seed', type=int, default=1, metavar='S', help='random seed (default: 1)’) 
    parser.add_argument('--save-model', action='store_true', default=False, help='For Saving the current Model') 
                        
    args = parser.parse_args() 
                        
                        
if __name__ == '__main__': 
    main()
```

**Logging formatter**

* Log의 결과값의 format을 지정

```python
formatter = logging.Formatter('%(asctime)s %(levelname)s %(process)d %(message)s')

'''
2018-01-18 22:47:04,385 ERROR 4410 ERROR occurred
2018-01-18 22:47:22,458 ERROR 4439 ERROR occurred
2018-01-18 22:47:22,458 INFO 4439 HERE WE ARE
2018-01-18 22:47:24,680 ERROR 4443 ERROR occurred
2018-01-18 22:47:24,681 INFO 4443 HERE WE ARE
2018-01-18 22:47:24,970 ERROR 4445 ERROR occurred
2018-01-18 22:47:24,970 INFO 4445 HERE WE ARE
'''
```

**Log config file**

```python
logging.config.fileConfig('logging.conf')
logger = logging.getLogger()
```

* logging.conf

![image-20220118211324946](https://user-images.githubusercontent.com/70505378/150050522-e2ef6dd9-5461-4e68-9b73-b8da89f0e301.png)

<br>

### 6. Python data handling

#### CSV

* CSV, 필드를 쉼표(,)로 구분한 텍스트 파일
* 엑셀 양식의 데이터를 프로그램에 상관없이 쓰기 위한 데이터 형식이라고 생각하면 쉬움

```python
import csv
reader = csv.reader(f, delimiter=',', quotechar='"', quoting=csv.QUOTE_ALL)
```

| Attribute      | Default       | Meaning                                             |
| -------------- | ------------- | --------------------------------------------------- |
| delimeter      | ,             | 글자를 나누는 기준                                  |
| lineterminator | \\r\\n        | 줄 바꿈 기준                                        |
| quotechar      | "             | 문자열을 둘러싸는 신호 문자                         |
| quoting        | QUOTE_MINIMAL | 데이터 나누는 기준이 quotechar에 의해 둘러싸인 레발 |



#### HTML

* World Wide Web(WWW), 줄여서 웹이라고 부름
* 우리가 늘 쓰는 인터넷 공간의 정식 명칭
* HTML 예시

```html
<!doctype html>
<html>
    <head>
        <title>Hello HTML</title>
    </head>
    <body>
        <p>Hello World!</p>
    </body>
</html>
```

* 파싱에는 **정규표현식 모듈 re**를 사용하거나 **BeautifulSoup** 모듈을 사용할 수 있음



#### XML

* 데이터의 구조와 의미를 설명하는 TAG(MarkUp)를 사용하여 표시하는 언어
* TAG와 TAG 사이에 값이 표시되고, 구조적인 정보를 표현할 수 있음
* XML은 컴퓨터 간에 정보를 주고받기 매우 유용한 저장 방식

* XML 예시

```xml
<?xml version="1.0"?> 
<고양이> 
    <이름>나비</이름> 
    <품종>샴</품종> 
    <나이>6</나이> 
    <중성화>예</중성화> 
    <발톱 제거>아니요</발톱 제거>
	<등록 번호>Izz138bod</등록 번호>
    <소유자>이강주</소유자>
</고양이>
```

* XML도 HTML과 같이 구조적 markup 언어
* 따라서 **정규 표현식** 또는 **BeautifulSoup**을 이용해 파싱 가능

```python
import urllib.request
from bs4 import BeautifulSoup

with open("US08621662-20140107.XML", "r", encoding="utf8") as patent_xml:
    xml = patent_xml.read() # File을 String으로 읽어오기

soup = BeautifulSoup(xml, "lxml") #lxml parser 호출

#invention-title tag 찾기
invention_title_tag = soup.find("invention-title")
print (invention_title_tag.get_text())
```



#### JSON

* JavaScript Object Notation
* 원래 웹 언어인 JavaScript의 데이터 객체 표현 방식
* 간결성으로 기계/인간이 모두 이해하기 편함
* 데이터 용량이 적고, Code로의 전환이 쉬움
* 이로 인해 XML의 대체제로 많이 활용

```json
{"employees":[ 
    {"name":"Shyam", 
    "email":"shyamjaiswal@gmail.com"}, 
    {"name":"Bob", 
    "email":"bob32@gmail.com"}, 
    {"name":"Jai", 
    "email":"jai87@gmail.com"} ]
} 
```

* JSON 파일의 구조를 확인 -> 읽어온 후 -> Dict type처럼 처리
  * json 모듈 사용

```python
# 읽기
import json

with open("json_example.json", "r", encoding="utf8") as f:
    contents = f.read()
    json_data = json.loads(contents)
    print(json_data["employees"])

# 쓰기
import json

dict_data = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}

with open("data.json", "w") as f:
    json.dump(dict_data, f)
```



<br>

<br>







## 피어세션 정리

오늘 피어세션에서는 어제까지의 팀원들의 학습 진도를 확인하고 조율하였다. 결과적으로 내일(수)까지 수강할 강의 및 과제에 대한 분량을 정하였다. 

또한, 강의 중 이해가 완벽히 가지 않았던 **가변 인자를 사용할 때의 Asterisk(\*)**나 **Decoration function의 동작 방식 및 사용 예시**에 대해 팀원들과 토론하였다. 이런 것이 피어세션의 순기능이라고 생각하고, 앞으로 계속해서 난이도가 높아질 강의와 과제에 있어 팀원들과 힘을 합쳐 헤쳐나갈 수 있었으면 좋겠다. 

<br>

<br>

## 과제 수행 과정/결과물

### 1. Basic_Math

리스트에서 최댓값, 최솟값, 평균값, 중간값을 찾는 문제였습니다. 

### 2. Text_Processing_I

문자열을 다루는 문제로, join(), lower(), split() 등의 메서드와 리스트 내포문을 사용하였습니다. 

### 3. Text_Processing_II

마찬가지로 문자열을 다루는 문제였습니다.

문자열에서 **특정 문자를 다른 문자로 치환(매핑)해주기 위해 딕셔너리를 활용**하였습니다.  

<br>

`문자열.split()` 메서드를 사용할 때, 인자로 아무것도 넘겨주지 않으면 default delimeter로 공백(" ")이 모두 삭제되는데, **특정 문자를 delimeter로 지정할 경우 그 문자가 2번 이상 연속되어 나타날 때 그 부분에서 하나만 삭제되고 다른 인접한 문자들은 공백 문자(' ')로 변환되어 남게 된다**는 것을 알았습니다. 

이는 **그 특정 문자로 공백(" ")을 지정해 줄 때도 마찬가지**입니다!

```python
str_ex = "abc&de&&fgh"
print(str_ex.split('&'))
str_ex_2 = "abc   def"
print(str_ex_2.split(" "))
str_ex_2 = "abc   def"
print(str_ex_2.split())

'''
['abc', 'de', '', 'fgh']
['abc', '', '', 'def']
['abc', 'def']
'''
```

따라서 이런 경우에는 그 특정 문자를 먼저 공백으로 `replace(특정문자," ")` 해주고, `split()`을 사용하는 것이 방법이 될 수 있습니다. 

<br>

또한 리스트 내포문에서 if와 if-else를 사용할 때 문법이 다른 것을 알았습니다. `if문` 만을 사용하는 경우 for문의 맨 뒤에 **조건문**으로 위치하고, `if-else 문`을 사용하는 경우 for문의 앞에 **삼항연산자**로 위치합니다. 

```python
# if
digit_string = " ".join([digit_to_word[w] for w in input_string if w in digit_to_word])
# if-else
camelscore_list = [w.capitalize() if i != 0 else w.lower() for (i,w) in enumerate(underscore_list)]
```



<br>

<br>

## 학습 회고

오늘은 파이썬의 자료구조, 파이써닉 코딩, 모듈과 프로젝트, 예외/파일/로그 핸들링 등에 대하여 학습하였다. 

파이썬을 계속해서 써왔기에 어려운 내용은 아니었지만, 단기간에 여러 내용을 듣고 학습하다 보니 정리하고 내 것으로 만드는 것이 쉽지는 않았다. 

그래도 강의와 과제에서 몰랐던 혹은 중요한 부분들을 많이 얻어가는 것 같아 파이썬에 대한 활용도가 한 층 더 상승한 것 같다. 

이렇게 처음부터 차근차근 정리하다 보면 이후에도 큰 도움이 될 것이라 생각한다. 
