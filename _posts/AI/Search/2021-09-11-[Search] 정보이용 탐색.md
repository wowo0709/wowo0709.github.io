---
layout: single
title: "[Search] 정보이용 탐색"
categories: ['AI', 'Search']
toc: true
toc_sticky: true
---

<br>

## 개요

지난 탐색 포스팅에서 **맹목적 탐색**에 대해 알아보았습니다. 

이번에 알아볼 탐색의 종류는 `정보이용 탐색`으로, `휴리스틱 탐색`이라고도 하는 탐색 기법입니다. 

<br>

### 휴리스틱

정해진 규칙에 따라 탐색을 진행하는 맹목적 탐색과 달리, 정보이용 탐색은 앞으로 **남은 거리에 대한 정보**를 이용합니다. 

이 때의 `정보`는 실제 남은 거리에 대한 것이 아니라, 남은 거리에 대한 **예측값**입니다. 

그리고 예측을 할 때 시간 또는 정보가 불충분하여 정확한 판단보다는 신속한 판단이 요구될 때 어림짐작 식으로 판단하는 것을 **휴리스틱**이라 합니다. 

예를 들어 지도 상의 최단 경로 문제에서 목적지까지의 실제 경로의 길이가 아닌 직선 경로의 길이를 정보로 사용하는 경우 등이 그렇습니다. 

![image-20210911220038054](https://user-images.githubusercontent.com/70505378/132949190-85c4f34a-9ec8-4507-a1ce-fdda86fe151e.png)

<br>

<br>

## 언덕 오르기 방법

`언덕 오르기 방법`(hill climbing method)은 다음과 같습니다. 

* 현재 노드에서 휴리스틱에 의한 평가값이 가장 좋은 이웃 노드로 이동합니다. 
* 국소 최적해(local optimal solution)에 빠질 가능성이 있습니다. 
* 그리디 알고리즘(greedy algorithm)입니다. 

매 위치마다 연결된 노드들 중 가장 최적의 노드로 이동하는 그리디 알고리즘의 일종이며, 목적지를 향해 다가가는 것이 언덕을 오르는 것과 비슷하다 하여 **언덕 오르기 방법**이라고 불립니다. 

![image-20210911220240909](https://user-images.githubusercontent.com/70505378/132949191-47916ac9-12a0-4f15-9052-2bb978c63c06.png)

<br>

<br>

## 최상 우선 탐색

`최상 우선 탐색`(best-first search)은 다음 특징을 갖습니다. 

* 이웃한 노드들 중에서 목표 노드까지 남은 거리가 가장 짧은 노드로 이동합니다. 
* 남은 거리를 정확히 알 수 없으므로 휴리스틱을 사용합니다. 

![image-20210911220613387](https://user-images.githubusercontent.com/70505378/132949192-13c7c279-5061-4752-9c21-c16da8163523.png)

<br>

<br>

## 빔 탐색

`빔 탐색`(beam search)은 앞서 살펴본 **최상 우선 탐색**에 더하여 휴리스틱에 의한 평가값이 우수한 <span style="color:red">**일정 개수(K)**</span>의 이웃 노드만을 탐색하는 방법입니다.  

확장 노드의 개수에 제한을 둠으로써 메모리를 효율적으로 관리할 수 있지만, 원하는 답을 찾지 못하게 될 수도 있습니다. 

![image-20210911221001256](https://user-images.githubusercontent.com/70505378/132949194-fab0d293-87a6-474c-b071-564b656ad75f.png)

<br>

<br>

## A* 알고리즘

마지막 정보이용 탐색 방법으로 `A* 알고리즘`(A star algorithm)이 있습니다. 

**A\* 알고리즘**은 **지금까지 온 경로의 비용도 판단의 기준에 포함**시킨다는 점에서 앞서 살펴본 방법들과 차이가 있습니다. 

<br>

이 알고리즘에서 사용하는 수식은 다음 모양과 같습니다. 

> f'(n) = g(n) + h'(n)

여기서 `g(n)`은 현재 노드까지 오는데 사용된 비용인 **실제 값**이고, `h'(n)`은 현재 노드에서 목적지 노드까지 가는 비용에 대응하는 휴리스틱 함수, 즉 **예측 값**입니다. 

`g(n)`과 `h'(n)`을 이용하여 `f'(n)`을 구함으로써 판단의 기준으로 사용하는 것입니다. 

<br>

다음은 A* 알고리즘을 이용하여 8-puzzle 문제를 푸는 모습을 나타낸 것입니다. 

![image-20210911221652155](https://user-images.githubusercontent.com/70505378/132949188-cce6b58b-682f-4f9d-9159-ab6d47a0f798.png)

