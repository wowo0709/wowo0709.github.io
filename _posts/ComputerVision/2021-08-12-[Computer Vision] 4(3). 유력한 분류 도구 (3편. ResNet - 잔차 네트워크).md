---
layout: single
title: "[Computer Vision] 4(3). 고급 아키텍처의 이해 (3편. ResNet - 잔차 네트워크)"
---



<br>

# 고급 아키텍처의 이해 (3편. ResNet - 잔차 네트워크)

ResNet은 ILSVRC 2015에서 우승(top-5 오차율 3.6%)을 차지한 아키텍처다. 새로운 유형의 모듈이 잔차 모듈로 구성되어 상당히 깊은 네트워크를 효율적으로 생성할 수 있는 방법을 제공해 인셉션 같은 큰 모델을 성능 측면에서 능가했다. 

<br>

### ResNet 아키텍처 개요

---

ResNet 아키텍처는 CNN에 영향을 미치는 학습 문제를 해결하는 흥미로운 솔루션이다. 

<br>

**동기**

이 아키텍처를 제안한 논문에서는 **네트워크가 지나치게 깊어질수록 '성능 저하'가 발생된다(기울기 소실/폭발 등의 이유로)**라는 문제를 제기했고, 매우 깊지만 성능이 우수한 네트워크를 구성할 수 있는 솔루션을 제안했다. 

<br>

**아키텍처**

ResNet은 VGG처럼 깊이에 따른 의사 표준화 버전(ResNet-18/50/101/152)이 있다. 이중 ILSVRC 2015 대회에서 우승을 거둔 네트워크는 가장 깊은 ResNet-152 모델이다. 
<img width="762" alt="KakaoTalk_20210812_165058991" src="https://user-images.githubusercontent.com/70505378/129166500-a31379c7-36c5-4bd4-9f47-a0c23783cdbc.png">

ResNet에서 모든 합성곱과 최대풀링 계층은 특별히 지정하지 않는 한 패딩 옵션으로 'SAME'을, 보폭으로 s=1을 사용한다. 3x3 합성곱 계층 다음마다 배치 정규화를 적용하고, 1x1 합성곱 계층에는 활성화 함수가 없다. 

ResNet 아키텍처 또한 인셉션 아키텍처와 유사하게 병렬 연산을 포함한 계층 블록으로 구성되지만, 그보다 더 얇다. 각 병렬 계층이 입력 정보를 비선형적으로 처리하는 입셉션 모델과 다르게, ResNet 블록은 하나의 비선형 경로와 하나의 항등 경로로 구성된다. 비선형 경로는 배치 정규화와 ReLU 활성화 함수와 함께 2개의 합성곱 계층을 입력 특징 맵에 적용하고, 선형 경로는 어떠한 변환도 적용하지 않고 단순히 특징을 전달한다. 

인셉션 모듈처럼 각 분기에서 얻은 특징맵은 다음 블록에 전달되기 전에 하나로 합쳐지지만, 인셉션 모델과는 다르게 이 통합은 **심도 결합**을 통해 수행하지 않고 단순히 **요소 단위 덧셈**을 통해 수행한다. 

마지막으로 GoogLeNet과 마찬가지로 최종 블록에서 얻은 특징에 평균풀링을 적용하고 밀도가 높은 예측으로 변환한다. 

<br>

**기여 - 정보를 더 깊은 계층으로 전방 전달**

잔차 블록은 머신러닝과 컴퓨터 비전 분야에 상당한 기여를 하였다. 

**1. _매핑 대신 잔차 함수 추정하기_**

ResNet 저자가 지적했듯이, 네트워크 계층이 **항등 매핑**을 쉽게 학습할 수 있다면(즉 계층이 가중치를 학습해 계층에서의 일련의 연산이 최종적으로 입력 텐서와 동일한 텐서를 반환한다면) 성능 저하는 발생하지 않을 것이다. 

잔차 블록의 아이디어는 다음과 같다. 

* 일부 추가적인 합성곱 계층을 사용해 데이터를 추가로 처리하는 경로

* 항등 매핑(즉, 데이터에 어떤 변경도 가하지 않고 전달)을 수행하는 경로

  <br>

  CNN 위에 잔차 블록을 추가하면 처리 분기의 가중치를 0으로 설정해 사전 정의된 항등 매핑만 남겨 최소한 원래 성능을 유지할 수 있다. 처리 경로는 손실 최소화 효과가 있을 경우에만 고려한다. 

<br>

CNN 위에 잔차 블록을 추가하면 처리 분기의 가중치를 0으로 설정해 사전 정의된 항등 매핑만 남겨 최소한 원래 성능을 유지할 수 있다. 처리 경로는 손실 최소화 효과가 있을 경우에만 고려한다. 

데이터 전달 경로는 일반적으로 **스킵** 또는 **숏컷**이라 부른다. 처리 경로는 보통 **잔차 경로(residual path)**라고 부른다. 그 이유는 그 경로 연산의 출력을 원본 입력에 더하는데, 이때 항등 매핑이 최적값에 가까울 때 처리된 텐서의 크기가 입력 텐서보다 훨씬 작기 때문이다. 전반적으로 이 잔차경로는 입력 데이터에 약간의 변화만을 가져오므로 더 깊은 계층으로 패턴을 전달할 수 있다. 

<br>

**2. _'극단적으로 깊이' 들어가기_**

잔차 블록은 전통 블록보다 매개변수가 많지 않으므로(스킵과 덧셈 연산에는 그 어떤 매개변수도 필요없기 때문에) '상당히 깊은' 네트워크를 구성할 때 효율적이다. 

더 최근에는 **하이웨이 네트워크**(각 잔차 블록에서 훈련 가능한 스위치 값을 사용해 어느 경로를 사용할 지 결정)나 **DenseNet 모델**(블록 사이에 스킵 연결을 추가)처럼 잔차 계산을 사용해 더 깊고 더 효율적인 네트워크를 구성하는 방법에 대한 연구가 진행되고 있다. 

<br>

<br>

### 텐서플로와 케라스로 구현하기

---

**케라스 함수형 API로 잔차 블록 구현하기**

<img width="355" alt="KakaoTalk_20210812_171541999" src="https://user-images.githubusercontent.com/70505378/129166511-d2025a07-004d-4330-a125-d395c9a092cd.png">

**잔차 경로**는 두 개의 합성곱 계층으로 구성되며 각 계층 뒤에는 배치 정규화가 따른다. 첫번째 합성곱 계층 바로 다음에는 ReLU 활성화 함수가 적용되고, 두번째 계층에서는 다른 경로와 통한된 후에만 활성화 함수가 적용된다. 

**숏컷 경로**는 더 단순하다. 이 경로에는 어떤 계층도 포함되지 않거나 단차 경로에서 차원을 변경하는 경우(예를 들어, 사용하는 보폭이 큰 경우) 입력 텐서의 형상을 조정하기 위해 1x1 합성곱 계층 하나만 포함한다. 

마지막으로 두 경로의 결과가 서로 더해지고 그 합에 ReLU 함수가 적용된다. 


```python
import tensorflow as tf
from tensorflow.keras.layers import Activation, Conv2D, BatchNormalization, add

def residual_block_basic(x, filters, kernel_size=3, strides=1):
    # 잔차 경로
    conv_1 = Conv2D(filters=filters, kernel_size=kernel_size, 
                    padding='same', strides=strides)(x)
    bn_1 = BatchNormalization(axis=-1)(conv_1)
    act_1 = Activation('relu')(bn_1)
    conv_2 = Conv2D(filters=filters, kernel_size=kernel_size, 
                    padding='same', strides=strides)(act_1)
    residual = BatchNormalizaiton(axis=-1)(conv_2)
    # 숏컷 경로
    shortcut = x if strides == 1 else Conv2D(filters, kernel_size=1, 
                                              padding='same', strides=strides)(x)
    # 결과 통합 및 반환
    return Activation('relu')(add([shortcut, residual]))
```

**텐서플로 모델과 텐서플로 허브**

ResNet 네트워크도 [tensorflow/models 깃 저장소](https://github.com/tensorflow/models/tree/master/research)에서 제공하는 공식 구현물과 함께 사전 훈련된 텐서플로 허브 모듈도 있다. 

**케라스 모델**

ResNet도 마찬가지로 tf.keras.applications.ResNet50()처럼 케라스 애플리케이션에서 제공하며, 시그니처는 여타 모델들과 동일하다. 이 케라스 애플리케이션을 사용하기 위한 전체 코드도 깃 저장소에서 제공한다. 

<br>

<br>

### 정리

---
이상 3편을 거쳐 컴퓨터 비전 영역에 적용할 수 있고 학습적 가치가 있는 솔루션을 다뤘습니다. 

시각 인식 분야의 연구가 빠르게 발전하면서, 이전 솔루션을 기반으로 구성하고(ResNet을 위해 하이웨이와 DenseNet 기법이 하는 것처럼), 통합해서(Inception-ResNet 솔루션처럼) 특정 용도에 맞게 최적화한(스마트폰에서 실행할 수 있게 구성된 가벼운 MobileNet처럼) 보다 진화된 아키텍처가 제안되고 있습니다. 따라서 이미 있는 모델을 다시 만드느라 시간을 낭비하기 전에 항상 최신 모델이 무엇을 제공하는지 확인해 보는 것이 좋을 것입니다. 
