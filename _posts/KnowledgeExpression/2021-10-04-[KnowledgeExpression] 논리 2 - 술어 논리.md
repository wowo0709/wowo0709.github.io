---
layout: single
title: "[Knowledge Expression] 논리 2 - 술어 논리"
categories: ['AI', 'KnowledgeExpression']
toc: true
toc_sticky: true
tag: []
---

<br>

## 논리

**말로 표현된 문장**들에 대한 타당한 추론을 위해, **기호**를 사용하여 문장들을 **표현**하고 **기호의 조작**을 통해 문장들의 **참 또는 거짓을 판정**하는 분야

<br>

## 술어 논리란?

### 술어 논리

명제의 내용을 다루기 위해 **변수, 함수** 등을 도입하고 이들의 값에 따라 참, 거짓이 결정되도록 명제 논리를 확장한 논리

<br>

### 술어

* 문장의 `주어 + 서술어` 형태에서 **서술어**에 해당

* 대상의 **속성**이나 **대상간의 관계**를 기술하는 기호

* **참** 또는 **거짓**을 부여하는 명제의 기본 형식

* 예

  ![image-20211006101636687](https://user-images.githubusercontent.com/70505378/136129765-113f3d03-e1eb-44e4-afd6-aa7c5852148a.png)

<br>

<br>

## 술어 논리의 구문

### 존재 한정사와 전칭 한정사

* 변수의 범위를 고려한 지식을 표현

* 예

  ![image-20211006101939688](https://user-images.githubusercontent.com/70505378/136129801-771d0e8a-5e07-4281-b96f-27a4aa006f21.png)

<br>

### 함수

* 주어진 인자에 대해서 **참, 거짓 값이 아닌 일반적인 값을 반환**
* 술어나 다른 함수의 인자로 사용

### 항

* 함수의 인자가 될 수 있는 것
* 항이 될 수 있는 것: 개체상수, 변수, 함수
  1. 개체 상수, 변수는 항이다. 
  2. t1, t2, ..., tn이 모두 항이고, f가 n개의 인자를 갖는 함수 기호일 때, f(t1, t2, ..., tn)은 항이다. 
  3. 1과 2에 의해 만들어질 수 있는 것만 항이다. 

<br>

### 술어 논리식에 대한 정형식

![image-20211006102310049](https://user-images.githubusercontent.com/70505378/136129832-48c5c847-bedf-4a99-833e-8669eeeff24a.png)

<br>

<br>

## 술어 논리의 종류

### 일차 술어논리 (first-order predicate logic, FOL)

**술어 기호의 인자로 사용될 수 있는 객체나 대상 만을 변수화할 수 있고**, 이들 변수에만 전칭 한정사와 존재 한정사를 쓸 수 있도록 한 술어논리

![image-20211006103107447](https://user-images.githubusercontent.com/70505378/136129854-aaef36d9-fe70-4f89-a5e2-d554fd8ab661.png)

<br>

### 고차 술어논리 (high-order predicate logic)

**함수나 술어기호도 변수화할 수 있고**, 이들 변수에 대해서도 전칭 한정사와 존재 한정사를 쓸 수 있도록 한 술어논리

![image-20211006103057834](https://user-images.githubusercontent.com/70505378/136129876-13c26a25-0395-4bf5-a3d4-42710de8e3ec.png)

<br>

<span style="color:red">**+추가**</span>

`일차술어 논리문`과 `고차술어 논리문` 의 구분법을 단순화하면 다음과 같다. 

> "술어논리문에서 함수나 술어 기호는 항상 괄호( )를 동반하므로 괄호 앞의 함수나 술어 기호가 상수가 아니고 변수라면 1차 술어논리문이 아니다. "

술어논리에서 어떤 것을 지칭하기 위한 용어(항, term)로서 `기호`를 이용하는데, **특정 개체(또는 객체, object)에 대해 기호를 사용하여 직접적으로 언급**하거나 (예: Mary 나 Tom이라는 사람에 대해 ' Mary' 나 'Tom' 이라는 기호를 사용하여 언급), 아니면 **함수기호와 인자를 사용하여 간접적으로 언급**할 수도 있습니다(예: Mary 가 Tom의 어머니인 경우 Motherof 라는 함수기호와 Tom 이라는 인자를 이용하여 Motherof(Tom) 라는 용어(항)로 실제의 Mary 를 언급)

그런데 여기서 ‘Motherof’ 와 ‘Tom’은 모두 `상수기호`입니다. ‘Motherof’는 누군가의 어머니를 나타내는 특정한 함수에 대한 기호로서 사용된 `함수상수(function constant)` 기호이고, ‘Tom’은 Tom이라는 특정 인물 을 언급하는데 사용된 `개체상수(object constant)` 기호입니다.) 우리가 지금 다루고 있는 **기호논리학(symbolic logic)**에서는 이렇게 **개체, 함수, 술어를 나타내는데 사용하는 기호 어떤 것이든 특정한 것을 나타내기 위해 사용하는 기호면 모두 다 `상수`**라 합니다. (보통 관습적으로 상수기호와 변수 기호를 구분하기 위해 대문자를 써서 상수를 나타내고, 소문자를 써서 변수를 나타냅니다.) 

그런데 `1차 술어논리`에서는 **함수명으로 사용하는 기호나 술어로 사용하는 기호를 변수화하여 문장으로 표현할 수 없다**는 것입니다. 함수기호나 술어기호를 변수화해서 문장을 만들면 그 문장은 1차술어논리 체계의 문장이 아니라 고차술어논리 체계의 문장이 되는 것입니다. 

예를 들어 아래의 문장에서 F, H, g는 인자를 하나씩 가지는 함수를 지칭하기 위해 사용된 기호인데, **F와 H 는 삼각함수 Sin 이나 Cos 함수처럼 특정함수를 나타내는 용어(상수)로서 사용된 상수 기호**이고, **g는 불특정한 함수를 지칭하는 용어(변수)로서 사용된 변수 기호**입니다. 따라서 아래의 문장은 1차 술어논리문은 아닙니다 ( a = b 형식의 문장 표현은 술어논리 문장의 형태인 = (a,b) 의 다른 표현이라고 가정하겠습니다) 

![image-20211007174107582](https://user-images.githubusercontent.com/70505378/136351118-33ba3c53-65d6-4db2-a405-908eb053a934.png)

위의 문장에서 g(x)를 G(x)로 바꿔 특정 함수를 지칭하는 상수 함수로 바꾸고, 앞의 전칭 한정사 ∃g 를 없애면 1차 술어 논리문이 될 것입니다. 

<Br>

반면, 다음의 문장은 1차 술어논리문입니다

![image-20211007174117083](https://user-images.githubusercontent.com/70505378/136351121-c36abc83-f627-4206-95c5-62442708649d.png)



<br>

<br>

## 술어 논리의 지식 표현

![image-20211006104642987](https://user-images.githubusercontent.com/70505378/136129889-886397e4-7e94-4a29-a0c1-805a01b575d1.png)

<br>

<br>

## 술어 논리의 추론

### 술어논리식의 CNF(논리곱 정규형)로의 변환 과정

**1. 전칭 한정사와 존재 한정사를 논리식의 맨 앞으로 끌어내는 변환**

**2. 전칭 한정사에 결합된 변수**

* 임의의 값 허용

**3. 존재 한정사에 결합된 변수**

* 대응되는 술어 기호를 참으로 만드는 값을 변수에 대응시킴

* <span style="color:blue">**스콜렘 함수** (Skolem function)</span>

  * 존재 한정사에 결합된 변수를 해당 술어의 **전칭 한정사**에 결합된 다른 **변수**들의 새로운 **함수로 대체**: <span style="color:red">**s(x)**</span>

  * 예

    ![image-20211006105340992](https://user-images.githubusercontent.com/70505378/136129924-8367fd89-7445-4444-800a-902022b8a35e.png)

정리하면 **술어논리식의 CNF로의 변환과정**은, 

* **전칭 한정사**만 존재하는 변수의 경우 논리식에서 전칭 한정사 삭제. 이는 변수에 임의의 값을 허용함을 뜻함. 
* **존재 한정사**만 존재하는 변수의 경우 대응되는 술어기호를 참으로 만드는 값을 변수에 대응. 
* **존재 한정사와 전치 한정사**가 함께 사용되는 경우 스콜렘 함수 사용

<br>

<br>

### 단일화 과정

논리융합을 적용할 때, 대응되는 리터럴이 같아지도록 변수의 값을 맞춰주는 과정

![image-20211006110108084](https://user-images.githubusercontent.com/70505378/136129938-e7f5b106-7121-459c-b07c-4d310e8acd4a.png)

<br>

### 술어 논리로 지식의 증명

<br>

![image-20211006110237664](https://user-images.githubusercontent.com/70505378/136129942-2b53d6fb-5579-477f-933c-3e0b2d3058f4.png)

<br>

![image-20211006110325029](https://user-images.githubusercontent.com/70505378/136129945-7d4df133-b81e-421d-9a31-5d12111469d1.png)

<br>

<br>

## 논리 프로그래밍 언어

* Horn 절

  * 논리식을 논리합의 형태로 표현할 때, `ㄱA(x) or ㄱB(x) or ㄱC(x)`와 같이 긍정인 리터럴을 최대 하나만 허용

* Prolog

  * Horn 절만 허용하는 논리 프로그래밍 언어

  ![image-20211006110557748](https://user-images.githubusercontent.com/70505378/136129947-adc935a8-f692-4864-ac5a-eb3c8485d283.png)

  * 백트래킹을 이용하여 실행

<br>

<br>







































