---
layout: single
title: "[Programmers] 다단계 칫솔 판매"
categories: ['Algorithm', 'Programmers']
toc: true
toc_sticky: true
tag: ['트리']
---



<br>

## 문제 설명

### 문제 설명

카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 '크루'라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.

이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자.

* 셔틀은 `09:00`부터 총 `n`회 `t`분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 `m`명의 승객이 탈 수 있다.
* 셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 `09:00`에 도착한 셔틀은 자리가 있다면 `09:00`에 줄을 선 크루도 탈 수 있다.

일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.

단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 `23:59`에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.

### 입력 형식

셔틀 운행 횟수 `n`, 셔틀 운행 간격 `t`, 한 셔틀에 탈 수 있는 최대 크루 수 `m`, 크루가 대기열에 도착하는 시각을 모은 배열 `timetable`이 입력으로 주어진다.

* 0 ＜ `n` ≦ 10
* 0 ＜ `t` ≦ 60
* 0 ＜ `m` ≦ 45
* `timetable`은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 `HH:MM` 형식으로 이루어져 있다.
* 크루의 도착 시각 `HH:MM`은 `00:01`에서 `23:59` 사이이다.

### 출력 형식

콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 `HH:MM` 형식이며, `00:00`에서 `23:59` 사이의 값이 될 수 있다.

### 입출력 예제

| n    | t    | m    | timetable                                                    | answer  |
| ---- | ---- | ---- | ------------------------------------------------------------ | ------- |
| 1    | 1    | 5    | ["08:00", "08:01", "08:02", "08:03"]                         | "09:00" |
| 2    | 10   | 2    | ["09:10", "09:09", "08:00"]                                  | "09:09" |
| 2    | 1    | 2    | ["09:00", "09:00", "09:00", "09:00"]                         | "08:59" |
| 1    | 1    | 5    | ["00:01", "00:01", "00:01", "00:01", "00:01"]                | "00:00" |
| 1    | 1    | 1    | ["23:59"]                                                    | "09:00" |
| 10   | 60   | 45   | ["23:59","23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59"] | "18:00" |

[해설 보러가기](http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/)

<br>

## 문제 풀이

### \# 완전탐색

<br>

### 풀이 과정

`n`도 작고 `m`도 작으니 시간 복잡도 `O(n*m)`으로 풀어봅시다. 

답이 될 수 있는 경우의 수는 다음의 두 가지 입니다. 

* **대기 인원 중에서 끊길 경우**: 맨 마지막 탄 사람의 도착 시각 - 1
* **한 명도 못 타거나 더 탈 수 있거나**: 맨 마지막 셔틀 운영 시각

코드는 여러 방식으로 구현할 수 있을텐데, 저는 셔틀을 탈 수 있는 도착 시각들을 `times`라는 리스트에 저장해놓기로 했습니다. 

문제를 풀면서 가장 골치 아팠던게 `마지막 셔틀 운영 시각이 마지막 대기 인원의 도착 시각과 같을 때 마지막 대기 인원을 태우고 더 태울 수 있는지 검사하는 부분`이었는데, 이를 해결하기 위해 다음과 같이 코드를 작성했습니다. 

<br>

### 전체 코드

전체 코드입니다. 

```python
def solution(n, t, m, timetable):
    timetable = sorted(list(map(lambda t: int(t[:2])*60+int(t[3:]), timetable)))
    times = [] # 셔틀을 탈 수 있는 사람들의 도착 시각
    now, num = 540, 0
    for i in range(n):
        for j in range(m):
            if num < len(timetable) and timetable[num] <= now:
                times.append((timetable[num],1)) # 실제로 대기 중인 사람이 탑승: (시간,1)
                num += 1
            else: times.append((now,0)) # 가상의 사람이 탑승: (시간,0)
        now += t
                
    ans = times[-1][0]-1 if times[-1][1] == 1 else times[-1][0]
    return str(ans//60).zfill(2) + ':' + str(ans%60).zfill(2)
```

<br>

### 정리







