---
layout: single
title: "[Programmers] 다음 큰 숫자"
categories: ['Algorithm', 'Programmers']
---


# 다음 큰 숫자

### 문제 설명

---

자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.

- 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.
- 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.
- 조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.

예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.

자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.

##### 제한 사항

- n은 1,000,000 이하의 자연수 입니다.

------

##### 입출력 예

| n    | result |
| ---- | ------ |
| 78   | 83     |
| 15   | 23     |

##### 입출력 예 설명

입출력 예#1
문제 예시와 같습니다.
입출력 예#2
15(1111)의 다음 큰 숫자는 23(10111)입니다.



### 문제 풀이

---

너무 쉬운 문제!

두 가지 방법으로 풀어보았는데, 뭔가 두 번째 방법은 괜히 한 느낌이... 그래도 코드는 올려보겠다!



#### 첫번째 방법

```python
def solution(n):
    cnt = bin(n).count('1')
    while True:
        n += 1
        if bin(n).count('1') == cnt: return n
```



문제를 읽으면 바로 떠오르는 방법이다. 

n부터 1씩 증가시키면서 해당 숫자의 2진수의 1의 갯수가 n의 1의 갯수와 같으면 return!



#### 두번째 방법

```python
def solution(n):
    n = bin(n)[2:]
    # 오른쪽부터 01을 10으로 바꿈(한번만)
    idx01 = n.rfind('01')
    if idx01 == -1: ans = n[0] + '0' + n[1:]
    else: ans = n[0:idx01] + '10' + n[idx01+2:]
    # 오른쪽부터 찾은 인덱스 아래까지 10을 01로 바꿈(계속)
    while True:
        idx10 = ans.rfind('10',idx01+2)
        if idx10 == -1: break
        else: ans = ans[0:idx10] + '01' + ans[idx10+2:]

    return int('0b'+ans,2)
```



위 방법은 다음 큰 숫자의 규칙을 찾아내서 구현한 코드인데..!!

실행 시간 면에서 이점이 있을 줄 알았지만 코드만 길고 실행 시간은 같았다 ㅠㅠ



그럼 안녕!
