---
layout: single
title: "[AITech] 2022년 1월 21일 학습 내용 정리"
categories: ['AI', 'AITech']
toc: true
toc_sticky: true
tag: ['판다스','CNN','RNN']
---



<br>

## 강의 복습 내용

### 1. Pandas I

#### Data loading


```python
import pandas as pd

data_url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.data'
df_data = pd.read_csv(data_url, sep='\s+', header=None)

df_data.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
      <th>10</th>
      <th>11</th>
      <th>12</th>
      <th>13</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.00632</td>
      <td>18.0</td>
      <td>2.31</td>
      <td>0</td>
      <td>0.538</td>
      <td>6.575</td>
      <td>65.2</td>
      <td>4.0900</td>
      <td>1</td>
      <td>296.0</td>
      <td>15.3</td>
      <td>396.90</td>
      <td>4.98</td>
      <td>24.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.02731</td>
      <td>0.0</td>
      <td>7.07</td>
      <td>0</td>
      <td>0.469</td>
      <td>6.421</td>
      <td>78.9</td>
      <td>4.9671</td>
      <td>2</td>
      <td>242.0</td>
      <td>17.8</td>
      <td>396.90</td>
      <td>9.14</td>
      <td>21.6</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.02729</td>
      <td>0.0</td>
      <td>7.07</td>
      <td>0</td>
      <td>0.469</td>
      <td>7.185</td>
      <td>61.1</td>
      <td>4.9671</td>
      <td>2</td>
      <td>242.0</td>
      <td>17.8</td>
      <td>392.83</td>
      <td>4.03</td>
      <td>34.7</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.03237</td>
      <td>0.0</td>
      <td>2.18</td>
      <td>0</td>
      <td>0.458</td>
      <td>6.998</td>
      <td>45.8</td>
      <td>6.0622</td>
      <td>3</td>
      <td>222.0</td>
      <td>18.7</td>
      <td>394.63</td>
      <td>2.94</td>
      <td>33.4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.06905</td>
      <td>0.0</td>
      <td>2.18</td>
      <td>0</td>
      <td>0.458</td>
      <td>7.147</td>
      <td>54.2</td>
      <td>6.0622</td>
      <td>3</td>
      <td>222.0</td>
      <td>18.7</td>
      <td>396.90</td>
      <td>5.33</td>
      <td>36.2</td>
    </tr>
  </tbody>
</table>

</div>



#### Series

* `Series(data, index, dtype)`: Series 객체를 생성


```python
from pandas import Series, DataFrame
import pandas as pd
import numpy as np
'''Series 객체 생성하기'''
# 리스트로 만들기
list_data = [1,2,3,4,5]
list_name = ["a", "b", "c", "d", "e"] # 리스트로 생성 시 data 길이와 index 길이 같아야 함
# list=name = ["a", "b", "c", "d", "e", "f", "g", "h"] -> error!!!
example_obj = Series(data=list_data, index=list_name)
print(example_obj, type(example_obj))
```

    a    1
    b    2
    c    3
    d    4
    e    5
    dtype: int64 <class 'pandas.core.series.Series'>



```python
# 딕셔너리로 만들기
dict_data = {"a":1, "b":2, "c":3, "d":4, "e":5}
indices = ["a", "b", "c", "d", "e", "f", "g", "h"] # data 길이와 달라도 index 기준
example_obj = Series(data=dict_data, index=indices, dtype=np.float32, name="example_data")
print(example_obj)
```

    a    1.0
    b    2.0
    c    3.0
    d    4.0
    e    5.0
    f    NaN
    g    NaN
    h    NaN
    Name: example_data, dtype: float32



```python
'''인덱스 접근'''
print(example_obj["a"])
example_obj["a"] = 3.5
print(example_obj)
```

    1.0
    a    3.5
    b    2.0
    c    3.0
    d    4.0
    e    5.0
    f    NaN
    g    NaN
    h    NaN
    Name: example_data, dtype: float32



```python
'''Series 프로퍼티'''
# values
print(example_obj.values)
# index
print(example_obj.index)
# name
example_obj.name = "number"
example_obj.index.name = "alphabet"
print(example_obj)
```

    [3.5 2.  3.  4.  5.  nan nan nan]
    Index(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'], dtype='object')
    alphabet
    a    3.5
    b    2.0
    c    3.0
    d    4.0
    e    5.0
    f    NaN
    g    NaN
    h    NaN
    Name: number, dtype: float32


#### DataFrame

* DataFrame(data, columns, index)


```python
'''딕셔너리 만들기'''
# 딕셔너리로 데이터프레임 생성
raw_data = {'first_name': ['Jason', 'Molly', 'Tina', 'Jake', 'Amy'], 
           'last_name': ['Miller', 'Jacobson', 'All', 'Milner', 'Cooze'], 
           'age': [42, 52, 36, 24, 73], 
           'city': ['San Francisco', 'Baltimore', 'Miami', 'Douglas', 'Boston']}
df = pd.DataFrame(data=raw_data)
# df = pd.DataFrame(data=raw_data, columns=['first_name', 'last_name', 'age', 'city'])
print(df)
```

      first_name last_name  age           city
    0      Jason    Miller   42  San Francisco
    1      Molly  Jacobson   52      Baltimore
    2       Tina       All   36          Miami
    3       Jake    Milner   24        Douglas
    4        Amy     Cooze   73         Boston



```python
# column 설정
print(DataFrame(raw_data, columns=["age", "city"]))
print(DataFrame(raw_data, columns=['first_name', 'last_name', 'age', 'city','debt']))
```

       age           city
    0   42  San Francisco
    1   52      Baltimore
    2   36          Miami
    3   24        Douglas
    4   73         Boston
      first_name last_name  age           city debt
    0      Jason    Miller   42  San Francisco  NaN
    1      Molly  Jacobson   52      Baltimore  NaN
    2       Tina       All   36          Miami  NaN
    3       Jake    Milner   24        Douglas  NaN
    4        Amy     Cooze   73         Boston  NaN



```python
'''인덱싱'''
# column 추출(Series 추출)
print(df.first_name) # df["first_name"]

# loc: 인덱스 이름
df.index = [3,4,0,1,2]
print(df)
print(df.loc[:2])

# iloc: 인덱스 순서
print(df.iloc[:2])
```

    0    Jason
    1    Molly
    2     Tina
    3     Jake
    4      Amy
    Name: first_name, dtype: object
      first_name last_name  age           city
    3      Jason    Miller   42  San Francisco
    4      Molly  Jacobson   52      Baltimore
    0       Tina       All   36          Miami
    1       Jake    Milner   24        Douglas
    2        Amy     Cooze   73         Boston
      first_name last_name  age           city
    3      Jason    Miller   42  San Francisco
    4      Molly  Jacobson   52      Baltimore
    0       Tina       All   36          Miami
    1       Jake    Milner   24        Douglas
    2        Amy     Cooze   73         Boston
      first_name last_name  age           city
    3      Jason    Miller   42  San Francisco
    4      Molly  Jacobson   52      Baltimore



```python
'''데이터프레임 핸들링'''
# 새로운 column 추가
df["debt"] = df.age > 40 # df.debt를 사용하려면 이미 그 열이 있어야만 함
print(df)

# column 삭제
del df["debt"] # df.drop(debt, axis=1, inplace=True)
print(df)
```

      first_name last_name  age           city   debt
    3      Jason    Miller   42  San Francisco   True
    4      Molly  Jacobson   52      Baltimore   True
    0       Tina       All   36          Miami  False
    1       Jake    Milner   24        Douglas  False
    2        Amy     Cooze   73         Boston   True
      first_name last_name  age           city
    3      Jason    Miller   42  San Francisco
    4      Molly  Jacobson   52      Baltimore
    0       Tina       All   36          Miami
    1       Jake    Milner   24        Douglas
    2        Amy     Cooze   73         Boston



```python
# transpose
print(df.T)
```

                            3          4      0        1       2
    first_name          Jason      Molly   Tina     Jake     Amy
    last_name          Miller   Jacobson    All   Milner   Cooze
    age                    42         52     36       24      73
    city        San Francisco  Baltimore  Miami  Douglas  Boston



```python
# 값 출력
print(df.values, type(df.values))
```

    [['Jason' 'Miller' 42 'San Francisco']
     ['Molly' 'Jacobson' 52 'Baltimore']
     ['Tina' 'All' 36 'Miami']
     ['Jake' 'Milner' 24 'Douglas']
     ['Amy' 'Cooze' 73 'Boston']] <class 'numpy.ndarray'>



```python
# csv 변환
print(df.to_csv())
```

    ,first_name,last_name,age,city
    3,Jason,Miller,42,San Francisco
    4,Molly,Jacobson,52,Baltimore
    0,Tina,All,36,Miami
    1,Jake,Milner,24,Douglas
    2,Amy,Cooze,73,Boston


​    

#### selection & drop


```python
'''Selection with column names'''
# column 한 개
print(df["age"].head(3))
# column 여러 개
print(df[["first_name", "last_name", "age"]].head(3))
```

    3    42
    4    52
    0    36
    Name: age, dtype: int64
      first_name last_name  age
    3      Jason    Miller   42
    4      Molly  Jacobson   52
    0       Tina       All   36



```python
'''Selection with index number'''
# 인덱스 이름
print(df.loc[:2])
# 인덱스 순서
print(df.iloc[:2]) # df[:2]
print(df.iloc[[0,2,4]])
# 열과 함께 선택
print(df["first_name"][:2])
# boolean 인덱스
print(df[df.age > 40])
```

      first_name last_name  age           city
    3      Jason    Miller   42  San Francisco
    4      Molly  Jacobson   52      Baltimore
    0       Tina       All   36          Miami
    1       Jake    Milner   24        Douglas
    2        Amy     Cooze   73         Boston
      first_name last_name  age           city
    3      Jason    Miller   42  San Francisco
    4      Molly  Jacobson   52      Baltimore
      first_name last_name  age           city
    3      Jason    Miller   42  San Francisco
    0       Tina       All   36          Miami
    2        Amy     Cooze   73         Boston
    3    Jason
    4    Molly
    Name: first_name, dtype: object
      first_name last_name  age           city
    3      Jason    Miller   42  San Francisco
    4      Molly  Jacobson   52      Baltimore
    2        Amy     Cooze   73         Boston



```python
'''Selection with column&index'''
# column name & index order
print(df[["first_name", "last_name"]][:3])
# index name & column name
print(df.loc[[3,4],["first_name", "last_name"]])
# index order & column order
print(df.iloc[:2,:3])
```

      first_name last_name
    3      Jason    Miller
    4      Molly  Jacobson
    0       Tina       All
      first_name last_name
    3      Jason    Miller
    4      Molly  Jacobson
      first_name last_name  age
    3      Jason    Miller   42
    4      Molly  Jacobson   52



```python
'''data drop'''
print(df)
# index name으로 drop
print(df.drop(1, axis=0))
print(df.drop([0,1,2,3],axis=0))
# column name으로 drop
print(df.drop("city", axis=1))
```

      first_name last_name  age           city
    3      Jason    Miller   42  San Francisco
    4      Molly  Jacobson   52      Baltimore
    0       Tina       All   36          Miami
    1       Jake    Milner   24        Douglas
    2        Amy     Cooze   73         Boston
      first_name last_name  age           city
    3      Jason    Miller   42  San Francisco
    4      Molly  Jacobson   52      Baltimore
    0       Tina       All   36          Miami
    2        Amy     Cooze   73         Boston
      first_name last_name  age       city
    4      Molly  Jacobson   52  Baltimore
      first_name last_name  age
    3      Jason    Miller   42
    4      Molly  Jacobson   52
    0       Tina       All   36
    1       Jake    Milner   24
    2        Amy     Cooze   73


#### dataframe operations


```python
'''Series operation'''
# index 기준으로 연산수행, 겹치는 index가 없을 경우 NaN값으로 반환
s1 = Series(range(1,6), index=list("abcde"))
s2 = Series(range(5,11), index=list("bcedef"))
print(s1, s2, sep='\n')
print(s1.add(s2)) # s1+s2
```

    a    1
    b    2
    c    3
    d    4
    e    5
    dtype: int64
    b     5
    c     6
    e     7
    d     8
    e     9
    f    10
    dtype: int64
    a     NaN
    b     7.0
    c     9.0
    d    12.0
    e    12.0
    e    14.0
    f     NaN
    dtype: float64



```python
'''dataframe operation'''
df1 = DataFrame(np.arange(9).reshape(3,3), columns=list("abc"))
df2 = DataFrame(np.arange(16).reshape(4,4), columns=list("abcd"))
print(df1, df2, sep='\n')
print(df1.add(df2, fill_value=0)) # fill_value
```

       a  b  c
    0  0  1  2
    1  3  4  5
    2  6  7  8
        a   b   c   d
    0   0   1   2   3
    1   4   5   6   7
    2   8   9  10  11
    3  12  13  14  15
          a     b     c     d
    0   0.0   2.0   4.0   3.0
    1   7.0   9.0  11.0   7.0
    2  14.0  16.0  18.0  11.0
    3  12.0  13.0  14.0  15.0



```python
'''series+dataframe'''
df = DataFrame(np.arange(16).reshape(4,4), columns=list('abcd'))
s2 = Series(np.arange(10,14))
print(df, s2, sep='\n')
print(df.add(s2, axis=0))
```

        a   b   c   d
    0   0   1   2   3
    1   4   5   6   7
    2   8   9  10  11
    3  12  13  14  15
    0    10
    1    11
    2    12
    3    13
    dtype: int32
        a   b   c   d
    0  10  11  12  13
    1  15  16  17  18
    2  20  21  22  23
    3  25  26  27  28


#### lambda, map, apply


```python
'''lambda, map'''
# 연산 적용
s1 = Series(np.arange(10))
print(s1.head(5))
print(s1.map(lambda x:x**2).head())
# dict type으로 데이터 치환(없는 값은 NaN)
z = {1:'A', 2:'B', 3:'C'}
print(s1.map(z).head())
# 같은 위치의 데이터를 s2로 교체
s2 = Series(np.arange(10, 20))
print(s1.map(s2).head())
```

    0    0
    1    1
    2    2
    3    3
    4    4
    dtype: int32
    0     0
    1     1
    2     4
    3     9
    4    16
    dtype: int64
    0    NaN
    1      A
    2      B
    3      C
    4    NaN
    dtype: object
    0    10
    1    11
    2    12
    3    13
    4    14
    dtype: int32



```python
'''replace'''
# map 함수의 기능 중 '데이터 변환' 기능만 담당
raw_data = {'earn': [79571, 96396, 48710], 
           'height': [73.89, 66.23, 63.77], 
           'sex': ["male", "female", "female"], 
           'race': ['white', 'white', 'black'], 
           'age': [49, 62, 33]}
df = pd.DataFrame(data=raw_data)
print(df.sex.replace({"male":0, "female":1}))
```

    0    0
    1    1
    2    1
    Name: sex, dtype: int64



```python
'''apply'''
# map과 달리, series 전체(column)에 해당 함수를 적용
df_info = df[["earn", "height", "age"]]
print(df_info.head())
f = lambda x: x.max() - x.min()
print(df_info.apply(f)) # 각 column 별로 결과값 반환

# sum, mean, std 등의 내장 연산 함수도 사용 가능
print(df_info.sum())
print(df_info.apply(sum))

# Series값으로 반환도 가능
def f(x):
    return Series([x.min(), x.max()], index=["min", "max"])
print(df_info.apply(f))
```

        earn  height  age
    0  79571   73.89   49
    1  96396   66.23   62
    2  48710   63.77   33
    earn      47686.00
    height       10.12
    age          29.00
    dtype: float64
    earn      224677.00
    height       203.89
    age          144.00
    dtype: float64
    earn      224677.00
    height       203.89
    age          144.00
    dtype: float64
          earn  height  age
    min  48710   63.77   33
    max  96396   73.89   62


#### Pandas built-in functions


```python
# describe 
print(df.describe()) # object type은 제외
```

                   earn     height        age
    count      3.000000   3.000000   3.000000
    mean   74892.333333  67.963333  48.000000
    std    24184.831824   5.277967  14.525839
    min    48710.000000  63.770000  33.000000
    25%    64140.500000  65.000000  41.000000
    50%    79571.000000  66.230000  49.000000
    75%    87983.500000  70.060000  55.500000
    max    96396.000000  73.890000  62.000000



```python
# unique
print(df.sex.unique())
```

    ['male' 'female']



```python
# 기본 연산
print(df.sum(axis=0))
print(df.mean(axis=1))
```

    earn                224677
    height              203.89
    sex       malefemalefemale
    race       whitewhiteblack
    age                    144
    dtype: object
    0    26564.630000
    1    32174.743333
    2    16268.923333
    dtype: float64



```python
# isnull
print(df.isnull())
print(df.isnull().sum())
```

        earn  height    sex   race    age
    0  False   False  False  False  False
    1  False   False  False  False  False
    2  False   False  False  False  False
    earn      0
    height    0
    sex       0
    race      0
    age       0
    dtype: int64



```python
# sort_values
print(df.sort_values(["age", "earn"], ascending=True))
```

        earn  height     sex   race  age
    2  48710   63.77  female  black   33
    0  79571   73.89    male  white   49
    1  96396   66.23  female  white   62



```python
# correlation & covariance
print(df.age.corr(df.earn))
print(df.age.cov(df.earn))
print(df.corrwith(df.earn))
print(df.corr())
```

    0.9941006402346648
    349232.5
    earn      1.000000
    height    0.392674
    age       0.994101
    dtype: float64
                earn    height       age
    earn    1.000000  0.392674  0.994101
    height  0.392674  1.000000  0.290608
    age     0.994101  0.290608  1.000000


### 

<br>

### 2. Pandas II

#### groupby I

* split -> apply -> combine


```python
df = {"Points": [876,789,863,673,741], 
     "Rank": [1,2,2,3,3], 
     "Team": ["Riders", "Riders", "Devils", "Devils", "Kings"], 
     "Year": [2014, 2015, 2014, 2015, 2014]}
df = pd.DataFrame(df)
print(df)
```

       Points  Rank    Team  Year
    0     876     1  Riders  2014
    1     789     2  Riders  2015
    2     863     2  Devils  2014
    3     673     3  Devils  2015
    4     741     3   Kings  2014



```python
print(df.groupby("Team"))
print(pd.DataFrame(df.groupby("Team")))
```

    <pandas.core.groupby.generic.DataFrameGroupBy object at 0x000001EEA6650F40>
            0                                                  1
    0  Devils     Points  Rank    Team  Year
    2     863     2 ...
    1   Kings     Points  Rank   Team  Year
    4     741     3  ...
    2  Riders     Points  Rank    Team  Year
    0     876     1 ...



```python
print(df.groupby("Team")["Points"])
print(pd.Series(df.groupby("Team")["Points"]))
```

    <pandas.core.groupby.generic.SeriesGroupBy object at 0x000001EEA6647D60>
    0    (Devils, [863, 673])
    1          (Kings, [741])
    2    (Riders, [876, 789])
    dtype: object





```python
df.groupby("Team")["Points"].sum() # 묶을 기준, 연산을 적용할 컬럼, 적용할 연산
```




    Team
    Devils    1536
    Kings      741
    Riders    1665
    Name: Points, dtype: int64




```python
df.groupby(["Team", "Year"])["Points"].sum()
```




    Team    Year
    Devils  2014    863
            2015    673
    Kings   2014    741
    Riders  2014    876
            2015    789
    Name: Points, dtype: int64




```python
df.groupby(["Year", "Team"])["Points"].sum() 
```




    Year  Team  
    2014  Devils    863
          Kings     741
          Riders    876
    2015  Devils    673
          Riders    789
    Name: Points, dtype: int64




```python
grouped_df = df.groupby(["Team", "Year"])["Points"].sum()
grouped_df.index
```




    MultiIndex([('Devils', 2014),
                ('Devils', 2015),
                ( 'Kings', 2014),
                ('Riders', 2014),
                ('Riders', 2015)],
               names=['Team', 'Year'])




```python
# 인덱싱
grouped_df["Devils":"Kings"]
```




    Team    Year
    Devils  2014    863
            2015    673
    Kings   2014    741
    Name: Points, dtype: int64




```python
# 묶여진 데이터를 matrix 형태로 전환
grouped_df.unstack()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>Year</th>
      <th>2014</th>
      <th>2015</th>
    </tr>
    <tr>
      <th>Team</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Devils</th>
      <td>863.0</td>
      <td>673.0</td>
    </tr>
    <tr>
      <th>Kings</th>
      <td>741.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Riders</th>
      <td>876.0</td>
      <td>789.0</td>
    </tr>
  </tbody>
</table>

</div>




```python
# 인덱스 변경
grouped_df.swaplevel()
```




    Year  Team  
    2014  Devils    863
    2015  Devils    673
    2014  Kings     741
          Riders    876
    2015  Riders    789
    Name: Points, dtype: int64




```python
print(grouped_df.sum(level=0))
print(grouped_df.sum(level=1))
```

    Team
    Devils    1536
    Kings      741
    Riders    1665
    Name: Points, dtype: int64
    Year
    2014    2480
    2015    1462
    Name: Points, dtype: int64


#### groupby II


```python
grouped_df = df.groupby("Team") 

for name, group in grouped_df:
    print(name)
    print(group)
```

    Devils
       Points  Rank    Team  Year
    2     863     2  Devils  2014
    3     673     3  Devils  2015
    Kings
       Points  Rank   Team  Year
    4     741     3  Kings  2014
    Riders
       Points  Rank    Team  Year
    0     876     1  Riders  2014
    1     789     2  Riders  2015



```python
grouped_df.get_group("Devils")
# grouped_df["Devils"] -> 컬럼 추출 용도(에러 발생)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Points</th>
      <th>Rank</th>
      <th>Team</th>
      <th>Year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>863</td>
      <td>2</td>
      <td>Devils</td>
      <td>2014</td>
    </tr>
    <tr>
      <th>3</th>
      <td>673</td>
      <td>3</td>
      <td>Devils</td>
      <td>2015</td>
    </tr>
  </tbody>
</table>

</div>



* 추출된 group 정보에는 3가지 유형의 apply가 가능함
  * Aggregation: 요약된 통계정보를 추출
  * Transformation: 해당 정보를 변환
  * Filtraion: 특정 정보를 제거하여 보여주는 필터링 기능


```python
# Aggregation
print(grouped_df.agg(sum))

import numpy as np
print(grouped_df.agg(np.mean))

print(grouped_df["Points"].agg([np.sum, np.mean, np.std]))
```

            Points  Rank  Year
    Team                      
    Devils    1536     5  4029
    Kings      741     3  2014
    Riders    1665     3  4029
            Points  Rank    Year
    Team                        
    Devils   768.0   2.5  2014.5
    Kings    741.0   3.0  2014.0
    Riders   832.5   1.5  2014.5
             sum   mean         std
    Team                           
    Devils  1536  768.0  134.350288
    Kings    741  741.0         NaN
    Riders  1665  832.5   61.518290


* transform 메서드는 key 값 별이 아닌 개별 데이터 별로 변환


```python
# Transformation
score = lambda x: x * 2
grouped_df.transform(score)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Points</th>
      <th>Rank</th>
      <th>Year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1752</td>
      <td>2</td>
      <td>4028</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1578</td>
      <td>4</td>
      <td>4030</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1726</td>
      <td>4</td>
      <td>4028</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1346</td>
      <td>6</td>
      <td>4030</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1482</td>
      <td>6</td>
      <td>4028</td>
    </tr>
  </tbody>
</table>

</div>



* 단, max나 min 처럼 Series 데이터에 적용되는 연산들은 key값을 기준으로 적용


```python
score = lambda x: max(x)
grouped_df.transform(score)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Points</th>
      <th>Rank</th>
      <th>Year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>876</td>
      <td>2</td>
      <td>2015</td>
    </tr>
    <tr>
      <th>1</th>
      <td>876</td>
      <td>2</td>
      <td>2015</td>
    </tr>
    <tr>
      <th>2</th>
      <td>863</td>
      <td>3</td>
      <td>2015</td>
    </tr>
    <tr>
      <th>3</th>
      <td>863</td>
      <td>3</td>
      <td>2015</td>
    </tr>
    <tr>
      <th>4</th>
      <td>741</td>
      <td>3</td>
      <td>2014</td>
    </tr>
  </tbody>
</table>

</div>




```python
# Filtration
grouped_df.filter(lambda x: len(x) >= 2) # 데이터가 2개 이상인 그룹
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Points</th>
      <th>Rank</th>
      <th>Year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>876</td>
      <td>1</td>
      <td>2014</td>
    </tr>
    <tr>
      <th>1</th>
      <td>789</td>
      <td>2</td>
      <td>2015</td>
    </tr>
    <tr>
      <th>2</th>
      <td>863</td>
      <td>2</td>
      <td>2014</td>
    </tr>
    <tr>
      <th>3</th>
      <td>673</td>
      <td>3</td>
      <td>2015</td>
    </tr>
  </tbody>
</table>

</div>




```python
grouped_df.filter(lambda x: x["Points"].sum() > 1600)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Points</th>
      <th>Rank</th>
      <th>Year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>876</td>
      <td>1</td>
      <td>2014</td>
    </tr>
    <tr>
      <th>1</th>
      <td>789</td>
      <td>2</td>
      <td>2015</td>
    </tr>
  </tbody>
</table>

</div>



#### Pivot table & Crosstab

* Excel에서 사용
* Index 축은 groupby와 동일
* column에 추가로 labeling 값을 추가하여, 
* value에 numeric type 값을 aggregation 하는 형태


```python
import dateutil
# Pivot table
df_phone = pd.read_csv("./phone_data.csv")
df_phone['date'] = df_phone['date'].apply(dateutil.parser.parse, dayfirst=True)
df_phone.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>index</th>
      <th>date</th>
      <th>duration</th>
      <th>item</th>
      <th>month</th>
      <th>network</th>
      <th>network_type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>2014-10-15 06:58:00</td>
      <td>34.429</td>
      <td>data</td>
      <td>2014-11</td>
      <td>data</td>
      <td>data</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>2014-10-15 06:58:00</td>
      <td>13.000</td>
      <td>call</td>
      <td>2014-11</td>
      <td>Vodafone</td>
      <td>mobile</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>2014-10-15 14:46:00</td>
      <td>23.000</td>
      <td>call</td>
      <td>2014-11</td>
      <td>Meteor</td>
      <td>mobile</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>2014-10-15 14:48:00</td>
      <td>4.000</td>
      <td>call</td>
      <td>2014-11</td>
      <td>Tesco</td>
      <td>mobile</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>2014-10-15 17:27:00</td>
      <td>4.000</td>
      <td>call</td>
      <td>2014-11</td>
      <td>Tesco</td>
      <td>mobile</td>
    </tr>
  </tbody>
</table>

</div>




```python
df_phone.pivot_table(["duration"], 
                    index=[df_phone.month, df_phone.item], 
                    columns=df_phone.network, 
                    aggfunc="sum", 
                    fill_value=0)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th colspan="9" halign="left">duration</th>
    </tr>
    <tr>
      <th></th>
      <th>network</th>
      <th>Meteor</th>
      <th>Tesco</th>
      <th>Three</th>
      <th>Vodafone</th>
      <th>data</th>
      <th>landline</th>
      <th>special</th>
      <th>voicemail</th>
      <th>world</th>
    </tr>
    <tr>
      <th>month</th>
      <th>item</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">2014-11</th>
      <th>call</th>
      <td>1521</td>
      <td>4045</td>
      <td>12458</td>
      <td>4316</td>
      <td>0.000</td>
      <td>2906</td>
      <td>0</td>
      <td>301</td>
      <td>0</td>
    </tr>
    <tr>
      <th>data</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>998.441</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>sms</th>
      <td>10</td>
      <td>3</td>
      <td>25</td>
      <td>55</td>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">2014-12</th>
      <th>call</th>
      <td>2010</td>
      <td>1819</td>
      <td>6316</td>
      <td>1302</td>
      <td>0.000</td>
      <td>1424</td>
      <td>0</td>
      <td>690</td>
      <td>0</td>
    </tr>
    <tr>
      <th>data</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1032.870</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>sms</th>
      <td>12</td>
      <td>1</td>
      <td>13</td>
      <td>18</td>
      <td>0.000</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>4</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">2015-01</th>
      <th>call</th>
      <td>2207</td>
      <td>2904</td>
      <td>6445</td>
      <td>3626</td>
      <td>0.000</td>
      <td>1603</td>
      <td>0</td>
      <td>285</td>
      <td>0</td>
    </tr>
    <tr>
      <th>data</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1067.299</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>sms</th>
      <td>10</td>
      <td>3</td>
      <td>33</td>
      <td>40</td>
      <td>0.000</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">2015-02</th>
      <th>call</th>
      <td>1188</td>
      <td>4087</td>
      <td>6279</td>
      <td>1864</td>
      <td>0.000</td>
      <td>730</td>
      <td>0</td>
      <td>268</td>
      <td>0</td>
    </tr>
    <tr>
      <th>data</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1067.299</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>sms</th>
      <td>1</td>
      <td>2</td>
      <td>11</td>
      <td>23</td>
      <td>0.000</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">2015-03</th>
      <th>call</th>
      <td>274</td>
      <td>973</td>
      <td>4966</td>
      <td>3513</td>
      <td>0.000</td>
      <td>11770</td>
      <td>0</td>
      <td>231</td>
      <td>0</td>
    </tr>
    <tr>
      <th>data</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>998.441</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>sms</th>
      <td>0</td>
      <td>4</td>
      <td>5</td>
      <td>13</td>
      <td>0.000</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

</div>



**Crosstab**

* 두 컬럼의 교차 빈도, 비율, 덧셈 등을 구할 때 사용
* Pivot table의 특수한 형태
* User-item Rating Matrix 등을 만들 때 사용 가능


```python
df_movie = pd.read_csv("./movie_rating.csv")
df_movie.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>critic</th>
      <th>title</th>
      <th>rating</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Jack Matthews</td>
      <td>Lady in the Water</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Jack Matthews</td>
      <td>Snakes on a Plane</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Jack Matthews</td>
      <td>You Me and Dupree</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Jack Matthews</td>
      <td>Superman Returns</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Jack Matthews</td>
      <td>The Night Listener</td>
      <td>3.0</td>
    </tr>
  </tbody>
</table>

</div>




```python
pd.crosstab(index=df_movie.critic, 
           columns=df_movie.title, 
           values=df_movie.rating, 
           aggfunc="first").fillna(0)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>title</th>
      <th>Just My Luck</th>
      <th>Lady in the Water</th>
      <th>Snakes on a Plane</th>
      <th>Superman Returns</th>
      <th>The Night Listener</th>
      <th>You Me and Dupree</th>
    </tr>
    <tr>
      <th>critic</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Claudia Puig</th>
      <td>3.0</td>
      <td>0.0</td>
      <td>3.5</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>2.5</td>
    </tr>
    <tr>
      <th>Gene Seymour</th>
      <td>1.5</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>5.0</td>
      <td>3.0</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>Jack Matthews</th>
      <td>0.0</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>5.0</td>
      <td>3.0</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>Lisa Rose</th>
      <td>3.0</td>
      <td>2.5</td>
      <td>3.5</td>
      <td>3.5</td>
      <td>3.0</td>
      <td>2.5</td>
    </tr>
    <tr>
      <th>Mick LaSalle</th>
      <td>2.0</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>3.0</td>
      <td>3.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>Toby</th>
      <td>0.0</td>
      <td>0.0</td>
      <td>4.5</td>
      <td>4.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>

</div>




```python
df_movie.pivot_table(["rating"], 
               index=df_movie.critic, 
               columns=df_movie.title, 
               aggfunc="first", fill_value=0)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="6" halign="left">rating</th>
    </tr>
    <tr>
      <th>title</th>
      <th>Just My Luck</th>
      <th>Lady in the Water</th>
      <th>Snakes on a Plane</th>
      <th>Superman Returns</th>
      <th>The Night Listener</th>
      <th>You Me and Dupree</th>
    </tr>
    <tr>
      <th>critic</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Claudia Puig</th>
      <td>3.0</td>
      <td>0.0</td>
      <td>3.5</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>2.5</td>
    </tr>
    <tr>
      <th>Gene Seymour</th>
      <td>1.5</td>
      <td>3.0</td>
      <td>3.5</td>
      <td>5.0</td>
      <td>3.0</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>Jack Matthews</th>
      <td>0.0</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>5.0</td>
      <td>3.0</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>Lisa Rose</th>
      <td>3.0</td>
      <td>2.5</td>
      <td>3.5</td>
      <td>3.5</td>
      <td>3.0</td>
      <td>2.5</td>
    </tr>
    <tr>
      <th>Mick LaSalle</th>
      <td>2.0</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>3.0</td>
      <td>3.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>Toby</th>
      <td>0.0</td>
      <td>0.0</td>
      <td>4.5</td>
      <td>4.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>

</div>



#### Merge & Concat

**merge**


```python
df_a = pd.DataFrame({"subject_id": [1,2,3,4,5,6], 
                   "test_score": [51,15,15,61,16,14]})
df_b = pd.DataFrame({"subject_id":[4,5,6,7,8], 
                    "first_name":["Billy", "Brian", "Bran", "Bryce", "Betty"], 
                    "last_name":["Bonder", "Black", "Balwner", "Brice", "Btisan"]})

pd.merge(df_a, df_b, on="subject_id")
# 두 데이터프레임의 컬럼명이 다를 경우
pd.merge(df_a, df_b, left_on="subject_id", right_on="subject_id")
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>subject_id</th>
      <th>test_score</th>
      <th>first_name</th>
      <th>last_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>4</td>
      <td>61</td>
      <td>Billy</td>
      <td>Bonder</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>16</td>
      <td>Brian</td>
      <td>Black</td>
    </tr>
    <tr>
      <th>2</th>
      <td>6</td>
      <td>14</td>
      <td>Bran</td>
      <td>Balwner</td>
    </tr>
  </tbody>
</table>

</div>




```python
print(pd.merge(df_a, df_b, on="subject_id", how="left")) # left join
print(pd.merge(df_a, df_b, on="subject_id", how="right")) # right join
print(pd.merge(df_a, df_b, on="subject_id", how="outer")) # full join
print(pd.merge(df_a, df_b, on="subject_id", how="inner")) # inner join
```

       subject_id  test_score first_name last_name
    0           1          51        NaN       NaN
    1           2          15        NaN       NaN
    2           3          15        NaN       NaN
    3           4          61      Billy    Bonder
    4           5          16      Brian     Black
    5           6          14       Bran   Balwner
       subject_id  test_score first_name last_name
    0           4        61.0      Billy    Bonder
    1           5        16.0      Brian     Black
    2           6        14.0       Bran   Balwner
    3           7         NaN      Bryce     Brice
    4           8         NaN      Betty    Btisan
       subject_id  test_score first_name last_name
    0           1        51.0        NaN       NaN
    1           2        15.0        NaN       NaN
    2           3        15.0        NaN       NaN
    3           4        61.0      Billy    Bonder
    4           5        16.0      Brian     Black
    5           6        14.0       Bran   Balwner
    6           7         NaN      Bryce     Brice
    7           8         NaN      Betty    Btisan
       subject_id  test_score first_name last_name
    0           4          61      Billy    Bonder
    1           5          16      Brian     Black
    2           6          14       Bran   Balwner



```python
# index based join
pd.merge(df_a, df_b, right_index=True, left_index=True)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>subject_id_x</th>
      <th>test_score</th>
      <th>subject_id_y</th>
      <th>first_name</th>
      <th>last_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>51</td>
      <td>4</td>
      <td>Billy</td>
      <td>Bonder</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>15</td>
      <td>5</td>
      <td>Brian</td>
      <td>Black</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>15</td>
      <td>6</td>
      <td>Bran</td>
      <td>Balwner</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>61</td>
      <td>7</td>
      <td>Bryce</td>
      <td>Brice</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>16</td>
      <td>8</td>
      <td>Betty</td>
      <td>Btisan</td>
    </tr>
  </tbody>
</table>

</div>



**concat**


```python
print(pd.concat([df_a, df_b]))
print(pd.concat([df_a, df_b], axis=1))
```

       subject_id  test_score first_name last_name
    0           1        51.0        NaN       NaN
    1           2        15.0        NaN       NaN
    2           3        15.0        NaN       NaN
    3           4        61.0        NaN       NaN
    4           5        16.0        NaN       NaN
    5           6        14.0        NaN       NaN
    0           4         NaN      Billy    Bonder
    1           5         NaN      Brian     Black
    2           6         NaN       Bran   Balwner
    3           7         NaN      Bryce     Brice
    4           8         NaN      Betty    Btisan
       subject_id  test_score  subject_id first_name last_name
    0           1          51         4.0      Billy    Bonder
    1           2          15         5.0      Brian     Black
    2           3          15         6.0       Bran   Balwner
    3           4          61         7.0      Bryce     Brice
    4           5          16         8.0      Betty    Btisan
    5           6          14         NaN        NaN       NaN


#### Persistence

* pickle persistence
* 가장 일반적인 python 파일 persistence
* to_pickle, read_pickle 함수 사용


```python
df = pd.DataFrame({"Points": [876,789,863,673,741], 
                 "Rank": [1,2,2,3,3], 
                 "Team": ["Riders", "Riders", "Devils", "Devils", "Kings"], 
                 "Year": [2014, 2015, 2014, 2015, 2014]})
print(df)
```

       Points  Rank    Team  Year
    0     876     1  Riders  2014
    1     789     2  Riders  2015
    2     863     2  Devils  2014
    3     673     3  Devils  2015
    4     741     3   Kings  2014



```python
df.to_pickle("./df_example.pickle")
df_pickle = pd.read_pickle("./df_example.pickle")
df_pickle
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }



</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Points</th>
      <th>Rank</th>
      <th>Team</th>
      <th>Year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>876</td>
      <td>1</td>
      <td>Riders</td>
      <td>2014</td>
    </tr>
    <tr>
      <th>1</th>
      <td>789</td>
      <td>2</td>
      <td>Riders</td>
      <td>2015</td>
    </tr>
    <tr>
      <th>2</th>
      <td>863</td>
      <td>2</td>
      <td>Devils</td>
      <td>2014</td>
    </tr>
    <tr>
      <th>3</th>
      <td>673</td>
      <td>3</td>
      <td>Devils</td>
      <td>2015</td>
    </tr>
    <tr>
      <th>4</th>
      <td>741</td>
      <td>3</td>
      <td>Kings</td>
      <td>2014</td>
    </tr>
  </tbody>
</table>

</div>

<br>

### 3. CNN 기초

#### Convolution

* 일반적인 다층 신경망(MLP)은 각 뉴런들이 선형 모델과 활성 함수로 **모두 연결된(fully connected) 구조**이다. 

* **Convolution 연산**은 이와 달리 **커널(필터)**을 **입력 벡터 상에서 움직여가면서** 선형모델과 함성 함수가 적용되는 구조이다. 

  * 컨볼루션 연산의 수학적 의미는 신호를 **커널을 이용해 국소적으로 증폭 또는 감소**시켜서 정보를 추출 또는 필터링하는 것이다. 

    ![image-20220121111508711](https://user-images.githubusercontent.com/70505378/150459184-30c78040-ff98-4640-b683-466e7aec286c.png)

  * CNN에서 사용하는 연산은 엄밀히 말하면 convolution 연산이 아니고 **cross-correlation** 연산이다. 하지만 그 의미에서 convolution 연산과 큰 차이가 없기 때문에 옛날부터 convolution 연산으로 통칭한다. 

  * 커널은 정의역 내에서 움직여도 변하지 않고(**translation invariant**) 주어진 신호에 국소적(**local**)으로 적용한다. 

  * 컨볼루션 연산은 1차원 뿐 아니라 다양한 차원에서 계산 가능하다. 

    * 데이터의 성격에 따라 사용하는 커널이 달라진다. 

    ![image-20220121111857484](https://user-images.githubusercontent.com/70505378/150459187-30d17340-932f-42dd-971c-8be5a51f555f.png)

* **2D-Conv** 연산은 아래와 같이 나타낼 수 있다. 

  ![image-20220121112045046](https://user-images.githubusercontent.com/70505378/150459189-a4fd7a4d-ac15-407b-af85-04aa6693d073.png)

  * 컨볼루션 연산에서 사용하는 용어로 **스트라이드**와 **패딩**이라는 것이 있다. 
    * **스트라이드**: 컨볼루션 연산을 위해 한 번에 필터(커널)를 이동시키는 칸 수
    * **패딩**: 컨볼루션 결과의 크기를 조정하기 위해 입력 배열의 둘레를 확장하고 0으로 채우는 연산

  ![image-20220121112643098](https://user-images.githubusercontent.com/70505378/150459190-fef4ea77-2a75-406b-9ed2-69d9897d5350.png)

  * 결과적으로 입력의 크기 (OH, OW), 커널(필터)의 크기(FH, FW), 패딩의 폭 P, 스트라이드 크기 S를 안다면 출력의 크기는 다음과 같이 구할 수 있다. 

    ![image-20220121112842880](https://user-images.githubusercontent.com/70505378/150459192-59f8d0da-27c2-48b7-b372-e7f3b25d43b0.png)

* 채널이 여러 개인 **3D-Conv** 이상의 다차원 컨볼루션 연산의 경우 **커널의 채널 수와 입력의 채널 수가 같아야** 한다. (rank가 동일해야 함)

  * 이 경우 3차원 입력과 3차원 커널을 통해 출력의 채널 크기는 1이 되며, 채널의 크기를 Oc로 만들고 싶다면 커널을 Oc개 사용하면 된다. 

  ![image-20220121113425774](https://user-images.githubusercontent.com/70505378/150459193-aa40617d-fa13-45a1-a289-aef42b5e19ce.png)

#### Convolution의 역전파

* 컨볼루션 연산은 커널이 모든 입력 데이터에 공통으로 적용되기 때문에 **역전파를 계산할 때도 convolution 연산**이 나오게 된다. 

![image-20220121114159506](https://user-images.githubusercontent.com/70505378/150459195-87f0536f-3e1c-48d5-9a49-794ea273b650.png)



<br>

### 4. RNN 기초

#### 시퀀스 데이터

* 소리, 문자열, 주가 등의 데이터를 **시퀀스 데이터**로 분류한다. 

* 시퀀스 데이터는 **독립동등분포(i.i.d.)** 가정을 위배하기 때문에 **순서를 바꾸거나 과거 정보에 손실이 발생하면 데이터의 확률분포도 바뀐다.**

* 따라서 이전 시퀀스에 대한 정보를 가지고 앞으로 발생할 데이터의 확률 분포를 계산해야 하며, 이를 위해 조건부 확률을 이용할 수 있다. 

  ![image-20220121114516596](https://user-images.githubusercontent.com/70505378/150459169-72a12f32-2439-4e73-840a-559be2d27ff9.png)

  * 위 조건부 확률은 과거의 모든 정보를 이용하지만, 시퀀스 데이터를 분석할 때 **과거의 모든 정보들이 필요한 것은 아니다.**
    * 어떤 시점까지의 과거의 정보를 이용할 지는 데이터/모델링에 따라 달라진다. 

* 시퀀스 데이터를 다루기 위해서는 **길이가 가변적인 데이터**를 다룰 수 있는 모델이 필요하다. 

  * 이를 해결하기 위해 특정 구간 _tau_만큼의 과거 정보만을 이용하고, 그보다 더 전의 정보들은 **H<sub>t</sub>**라는 잠재변수로 인코딩해서 사용할 수 있다. 
    * 이렇게 함으로써 데이터의 길이를 고정할 수 있고, 과거의 모든 데이터를 활용하기 용이해진다. 

  ![image-20220121115240369](https://user-images.githubusercontent.com/70505378/150459172-8ac5d9c3-3ce5-49d9-9db9-8482e2071342.png)

  * 이 잠재변수 H<sub>t</sub>를 신경망을 통해 반복해서 사용하여 **시퀀스 데이터의 패턴을 학습**하는 모델이 **RNN**이다. 

    <img src="https://user-images.githubusercontent.com/70505378/150459173-7e1479bf-afb5-454a-8336-ef95b1282c8c.png" alt="image-20220121115433935" style="zoom:67%;" />

#### RNN(Recurrent Neural Network)

* 현재 정보만을 입력으로 사용하는 완전연결신경망은 과거의 정보를 다룰 수 없다. 

* RNN은 이전 순서의 잠재변수와 현재의 입력을 활용하여 모델링한다. 

  * W: t에 따라 불변/ X, H: t에 따라 가변

  ![image-20220121115906209](https://user-images.githubusercontent.com/70505378/150459174-3020b45d-4248-4ff1-b8fa-bf36b10fa114.png)

* **RNN의 역전파**는 잠재변수의 연결그래프에 따라 순차적으로 계산한다. (맨 마지막 출력까지 계산한 후에 역전파)

  * 이를 **BPTT(Backpropagation Through Time)**라 하며 RNN의 기본적인 역전파 방식이다. 

  ![image-20220121120052256](https://user-images.githubusercontent.com/70505378/150459175-d0158bca-a493-49b7-9272-adc6d1ca8496.png)

  * BPTT를 통해 RNN의 가중치 행렬의 미분을 계산해보면 아래와 같이 **미분의 곱**으로 이루어진 항이 계산된다. 

    * 그 중 빨간색 네모 안의 항은 불안정해지기 쉽다. 
    * 이는 거듭된 값들의 곱으로 인해 값이 너무 커지거나(기울기 폭발) 너무 작아져(기울기 소실) 과거의 정보를 제대로 전달해주지 못하기 때문이다. 

    ![image-20220121120521892](https://user-images.githubusercontent.com/70505378/150459177-ae598173-a0df-431f-a4a6-538baf34ae44.png)

  * 기울기 폭발/소실 문제를 해결하기 위해 역전파 과정에서 **길이를 끊는 것**이 필요하며, 이를 **TBPTT(Truncated BPTT)**라 한다. 

    ![image-20220121120714788](https://user-images.githubusercontent.com/70505378/150459180-30e736f3-3b17-4191-a09e-85417f3d37b5.png)

* 여러가지 문제로 Vanilla RNN으로는 긴 시퀀스를 처리하는데 한계가 있고, 이를 해결하기 위해 **LSTM**이나 **GRU**와 같은 발전된 형태의 네트워크를 사용한다. 

  ![image-20220121120933072](https://user-images.githubusercontent.com/70505378/150459183-54dfba71-66b6-4bf0-8d54-1c7fbaec5427.png)



<br>

<br>

## 피어세션 정리



<br>

<br>

## 과제 수행 과정/결과물



<br>

<br>

## 학습 회고



















